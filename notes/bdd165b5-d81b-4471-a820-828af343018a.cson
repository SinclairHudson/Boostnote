createdAt: "2020-07-24T18:47:21.681Z"
updatedAt: "2020-08-14T19:21:41.093Z"
type: "MARKDOWN_NOTE"
folder: "b98556b417c909bf839c"
title: "Week 11: Virtual Memory"
tags: []
content: '''
  # Week 11: Virtual Memory
  
  We're focusing on the connection between cache and disk now.
  
  How does a single processor run two processes at the same time?
  
  Well it doesn't actually, it just looks like it does that. It loads some of program 1, executes that, then executes some of program 2, and executes that. It loads page at a time. It saves the state of the programs before it gets flushed from the CPU. We're swapping in and swapping out.
  
  Programs are stored on the disk in **pages**. The page size is generally $4KB$. That's a lot, because going to disk is very slow.
  
  Virtual memory is the **organizing relationship between RAM and disk.**
  Every program thinks it has unlimited memory. Of course, it does not.
  
  We use RAM of 4GB, which means and address space of 32 bits.
  
  Remember, every program thinks it starts at address 0, but it has a different physical address in main memory.
  
  Someone has to tell the CPU where in physical memory where the data it needs is. Who keeps track of the mapping of programs in physical memory?
  
  The **Page Table** is this mapping. It translates virtual addresses to physical addresses.
  
  There's a dedicated spot in main memory where the page tables are stored. Each program has a page table.
  
  The processor has a **page table register** which is a pointer to the page table for the current program.
  
  ![e3f6188a.png](:storage/bdd165b5-d81b-4471-a820-828af343018a/e3f6188a.png)
  
  What if the virtual page doesn't exist in main memory yet? This is called a **page fault**. So we have to fetch it from disk.
  
  Virtual addresses of pages can point to disk or RAM. There's a **valid bit** in the page table, that tells us if the page is in physical RAM or if it's on disk.
  If the valid bit is 0, the rest of the data in that entry is meaningless.
  
  ![d86ca630.png](:storage/bdd165b5-d81b-4471-a820-828af343018a/d86ca630.png)
  
  Pages are copied from disk to RAM. It's always a copy down.
  
  So, when doing a lookup for a virtual page number, you will always find the entry in the page table. However, it may be invalid.
  
  
  A virtual address is comprised of two parts: $VPN: Offset$. So $0:016$ would be an offset of 16 from the start of the physical page that was found in the page table.
  
  An offset into the page is normally 12 bits.
  
  ![ec9b24cf.png](:storage/bdd165b5-d81b-4471-a820-828af343018a/ec9b24cf.png)
  
  
  We've been living in virtual addresses up to this point.
  
  We use the same "dirty bit" system for pages in between RAM and disk.
  
  !!! question What if my page table is absolutely massive? Like my program has 5000 pages to it?
  You can actually page the page table itself. This is like a multi-level page table.
  !!!
  
  The offset does not have to be a multiple of 4 or 8.
  
  ---
  
  We can optimize by caching parts of the cache table.
  
  This cache is called the **TLB**.
  
  ![5f46680c.png](:storage/bdd165b5-d81b-4471-a820-828af343018a/5f46680c.png)
  
  The parent of the TLB is the page table.
  
  The TLB contains the popular pages. These pages are only in RAM, because they're popular. When a page goes back to disk, it gets removed from the TLB (invalid).
  
  ![0e0f0c24.png](:storage/bdd165b5-d81b-4471-a820-828af343018a/0e0f0c24.png)
  
  Dotted lines are misses, and solid lines are what you check first.
  
  ---
  
  There's a control flow:
  ```
  PC has a virtual address
  if(TLB hit on the virtual address){
    we have the PA, and it's either in cache or RAM
    if(cache hit on PA){
      best case scenario, we have the data. Done.
    }
    else(cache miss){
      grab data from RAM, using the PA. Done, ez.
      Update Cache, since this was just used.
    }
  }
  else(TLB miss){
    go to page table
    if(Page table HIT){
      we have a PA now.
      if(cache hit on PA){ //use the index bits in the PA now, to find.
        We have a good, updated version. EZ.
        update TLB.
      }
      else(cache miss on PA){
        Grab from RAM. We're guaranteed to find it because it was in the PT.
        Update both TLB and CACHE (they were both misses.)
      }
    }
    else(Page table MISS){
      This is a page fault.
      We need to go to disk, and bring it to RAM. This potentially removes a page
      from RAM, potentially writing an updated version to disk. 
      When a page is removed in RAM, it is also removed in cache and TLB.
      In this case, we also have to update the Page Table and TLB, to keep it up to date.
    }
  }
  ```
  
  ![b8543c6b.png](:storage/bdd165b5-d81b-4471-a820-828af343018a/b8543c6b.png)
  
  7 is possible.
  
  ---
  
  Addresses are in HEX.
  There's a row for every single virtual page in the page table.
  They're indexed by the virtual page numbers. so VP 6's entry in the page table it at row 6.
  The TLB is not organized like this; it's random.
  
  ![c5395c7b.png](:storage/bdd165b5-d81b-4471-a820-828af343018a/c5395c7b.png)
  
  We fill prages in RAM from the bottom up.
  
  This video, Week 11: PageTable_TLB goes over the process of a ton of LDUR instructions and how the TLB and PT work.
  
  There's a special reference bit per address. The OS checks the reference bit to know which entry to kick out. Every 1000cc or something, an external controller finds entries that haven't been used in a while and purges them so that new pages can be loaded in.
  We just have to worry about turning on the reference bits when we use that entry. We have to update this bit in both the PT and TLB.
  There's probably an extra controller that syncs reference bits from TLB to PT, so the current process doesn't have to halt.
  
  
  STUR is unique in that it writes to data cache. We turn on the dirty bit, so when the entry is cleared it knows to write that data from cache back to RAM or RAM back to disk (in that order).
  
  When you evict from the TLB, you don't evict from the PT or the actual data in RAM. Also, you go top-down and evict the one that doesn't have a reference bit of 1 first. That's because it wasn't referenced recently.
  
  When you evict from RAM, you also need to evict from TLB and CACHE and the PT. If there's a dirty bit, these are write-backs, from cache to RAM to disk. 2 levels of dirty bits, 2 writebacks.
  
  ---
  
  When there are multiple programs, they switch between them (time slicing), doing parts of program 1 then program 2 then program 1 ... each program is called a process.
  
  When switching, we save some of the state of the cpu.
  We save the **PC** of where we left off.
  We also need to store the **register file**.
  
  The swap space is very close to the datapath, and it's where other states are stored for the different processes.
  
  
  
  
'''
linesHighlighted: []
isStarred: false
isTrashed: false
