{"_id":"note:op2Md-PZEUy","title":"Problem 23: Shared Ownership","content":"## Problem 23: Shared Ownership\n\nThe unique_ptrs that we wrote don't respect \"is_a\".\n\n```cpp\nunique_ptr<Base> p = {new Derived {...}} //OK\np->virt_fn(); //runs Derived version. OK\n```\nBUT,\n\n```cpp\nunique_ptr<Derived> q = ~~~~~\nunique_ptr<Base> p = std::move(q); //X Type error - no conversion between unique_ptr<Derived> and unique_ptr<Base>\n```\nBut this is easy to fix.\n```cpp\ntemplate<typename T> ckass unique_ptr{\n~~~ T*p;\npublic:\n  ~~~\n  template <typename U> unique_ptr(unique_ptr<U> &&q):\n    p{q.p}{q.p = nullptr;}\n  template <typename U> unique_ptr &operator=(unique_ptr<U> &&q){\n    std::swap(q.p,p);\n    return *this;\n  }\n};\n```\n\nI want two unique pointers that point to the same thing! It's not unique at that point, but you get the idea. Why not have one `unique_ptr` while the others are just raw pointers. When do you __truly__ want shared ownership?\n\nRecall, in Racket:\n```\n(define l1 (cons 1 (cons 2 (cons 3 empty))))\n(define l2 (cons 4 (rest l1)))\n# they have shared tails!\n```\nBut shared data structures are a **nightmare** in C.\nHow can we ensure that each node is freed exactly once? This is easy in garbage-collected languages.\n\nEnter `shared_ptr`\n\n```cpp\ntemplate <typename T> class shared_ptr{\n  T*p;\n  int *refcount; //counts how many shared_ptrs point to *p;\n  //p is deleted when its refcount reaches 0.\n  public:\n  ~~~~~\n}\n```\n\n```cpp\nstruct Node{\n  int data;\n  shared_ptr<Node> next;\n}\n```\nThis node in a linked list structure is easy. the deallocation happens automatically. \nUNLESS, we have a cycle. Then the ref count will never get to 0. You may have to break the cycle.\n\nAlso watch:\n```cpp\nBook *p = new Book ~~~~~;\nshared_ptr<Book> p1 {p};\nshared_ptr<Book> p2 {p};\n\n```\n\n!!! danger This is wrong\nThis is two shared pointers, they will not share a ref count. To point 2 shared pointers at the same object, initialize one from the object and then copy the shared pointer. \n!!!\n\nBut you can't dynamic cast shared pointers...\nSO WE'LL WRITE OUR OWN!\n```cpp\ntemplate<typename T, typename U> shared_ptr<T>\ndynamic_pointer_cast(const shared_ptr<u> &spu){\n  // this is a little tricky\n  auto p= dynamic_cast<T*>(spu.get()); //check to see if the underlying pointer is castable\n  if(p){\n    return shared_ptr<T>{spu, p};\n  }\n  else{\n    return shared_ptr<T>{};\n  }\n}\n```\nSimilarly, there is `const_pointer_cast` and `static_pointer_cast`.\n\nDon't try to shortcut the ownership rules.","tags":[],"folderPathname":"/CS246E","data":{},"createdAt":"2019-11-14T16:03:23.946Z","updatedAt":"2019-11-19T15:30:42.315Z","trashed":false,"_rev":"WnXX3ZA2Xn9"}