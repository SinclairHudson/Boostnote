{"_id":"note:j75uOGfcyKJ","title":"Problem 08: Efficient Iteration","content":"## Problem 08: Efficient Iteration\n\n```cpp\nvector v;\nv.push_back(...);\n...\nfor(size_t i=0; i<v.size();++i){\n  cout << v[i] << endl;\n}\n```\n$$O(n)$$\nGreat.\nLet's do the same thing with a list.\n```cpp\nlist l;\nl.push_back(...);\n...\nfor(size_t i=0; i<l.size();++i){\n  cout << l[i] << endl; //O(i)\n}\n```\n$$O(n^2)$$\nOOF. In obscuring the node, we made the retrieval linear time complexity.\n\n!!! note Design Patterns\nA problem that comes up a lot, and here's a solution that a lot of people have thought about and is proven to work. Can be adapted to suit current needs.\n!!!\n\n!!! note Iterator Pattern\nFor efficient iteration over a collection without exposing underlying structure.\n!!!\n\n**The idea**: create a class that \"remembers\" where you are in the list.\nThis is an abstraction of a pointer.\n\n##### Inspiration: C\n```c\nfor(int *p=arr; p!=a+size; ++p){\n  print(\"%d\\n\", *p);\n}\n```\nNow in C++\n```cpp\nclass list{\nstruct Node{...};\nNode *theList;\npublic:\n  class iterator{ //nested public class! \n    Node *p;\n    public:\n    iterator (Node *p):p{p}{} //this iterator object is like the pointer in the above C code.\n    bool operator!=(const iterator &other)const{return p!=other.p;}\n    iterator &operator++(){p=p->next; return *this;}\n    int &operator*(){return p->data;}\n  }\n  iterator begin(){return iterator {theList};}\n  //iterator needs to be one past the end of the list.\n  iterator end(){return iterator{nullptr};}\n};\n\nlist l;\n... //populate\nfor(list::iterator it= l.begin; it!=l.end(); ++it){\n  cout *it <<endl;\n} //We're back to O(n)\n```\n\nShould list::begin and list::end be const methods?\n\nConsider:\n```cpp\nostream &operator<<(ostream &out, const list &l){\n  for(list::iterator it=l.begin(); it!=l.end(); ++it){\n    out << *it <<endl; //this won't compile if begin/end are not const.\n  }\n  return out;\n}\n```\nOk, so let's suppose they are const:\n```cpp\nostream &operator<<(ostream &out, const list &t){\n  for(list::iterator it=l.begin(); it!=l.end(); ++it){\n    out << *it <<endl;\n    ++*it; //WILL compile, but it shouldn't. Because the list should be const.\n    //operator * returns a non-const ref.\n    //but it should compile if the list is not const.\n  }\n  return out;\n}\n```\nThe act of iterating over a const list vs a non-const list are two different things.\n\nSo uhhh, we need a **seperate iterator class**.\n```cpp\nclass list{\nstruct Node{...};\nNode *theList;\npublic:\n  class iterator{\n    Node *p;\n    public:\n    iterator (Node *p):p{p}{} //this iterator object is like the pointer in the above C code.\n    \n    bool operator!=(const iterator &other)const{\n      return p!=other.p;\n    }\n    iterator &operator++(){\n      p=p->next; return *this;\n    }\n    int &operator*(){ \n      return p->data;\n    }\n  };\n  class const_iterator{\n    Node *p;\n    public:\n      const_iterator(Node *p):p{p}{}\n      \n      bool operator!=(const const_iterator &other)const{\n        return p!=other.p;\n      }\n      const_iterator &operator++(){\n        p=p->next; return *this;\n      }\n      const int &operator*() const{ //dereference\n        return p->data;\n      }\n  };\n  \n  iterator begin(){\n    return iterator {theList};\n  }\n  //iterator needs to be one past the end of the list.\n  iterator end(){\n    return iterator{nullptr};\n  }\n  //const overloading\n  const_iterator begin() const{return const_iterator{theList};}\n  const_iterator end() const {return const_iterator{nullptr};}\n\n  ostream &operator <<(ostream &out, const list &l){\n    for(list::const_iterator it=l.begin(); it!= l.end(); ++it){\n      out << *it<<endl;\n    }\n    return out;\n  }\n}; //end of list class\n```\nSo now begin and end will do the same thing\n```cpp\nlist::const_iterator it=l.begin() //mouthful.\n\nostream &operator<<(....){\n  for(auto it=l.begin(); int!=l.end(); ++it){\n    out << *it<<endl;\n  }\n}\n```\n!!! note `auto`\nI'm too lazy to write the type down. The type I mean for x to have is the type expr's type. Whatever the expression returns, that's what it will be.\n!!!\nEVEN SHORTER:\n```cpp\nostream &operator<<(....){\n  for(auto it:l){ //range-based for loops\n    out << *it<<endl;\n  }\n}\n```\nAvailable for any class with\n1) methods `begin` and `end` that return an iterator object\n2) the iterator object must support unary \\*, prefix ++, and !=\n\n`for(auto n:l) ++n` will compile, but n was declared by value. `++n` increments n, not the list values.\n`for(auto &n:l) ++n` will update the list items, because now `n` is a reference.\n`for(const auto &n:l) ++n` will not work, because `n` cannot be mutated.\n\nOne small encapsulation problem:\nclient: `list::iterator it{nullptr};`\n!!! error forgery - can create an end iterator without calling `l.end()`\n!!!\nWe could fix this by making iterator constructors private. But then list can't create an iterator.\n\nSolution: friendship.\n\n```cpp\nclass list{\nstruct Node{...};\nNode *theList;\npublic:\n  class iterator{\n    Node *p;\n    iterator (Node *p):p{p}{} \n    public:\n    bool operator!=(const iterator &other)const{return p!=other.p;}\n    iterator &operator++(){p=p->next; return *this;}\n    int &operator*(){return p->data;}\n    friend class list; //list has access to all of iterator\n\n  };\n  class const_iterator{\n    Node *p;\n    const_iterator(Node *p):p{p}{}\n    public:\n      bool operator!=(const const_iterator &other)const{\n        return p!=other.p;\n      }\n      const_iterator &operator++(){p=p->next; return *this;}\n      const int & operator*()const{return p->data;}\n      friend class list; //list has access to all of iterator\n  };\n  \n  iterator begin(){return iterator {theList};}\n  //iterator needs to be one past the end of the list.\n  iterator end(){return iterator{nullptr};}\n  //const overloading\n  const_iterator begin() const{return const_iterator{theList};}\n  const_iterator end() const {return const_iterator{nullptr};}\n\n  ostream &operator <<(ostream &out, const list &l){\n    for(list::const_iterator it=l.begin(); it!= l.end(); ++it){\n      out << *it<<endl;\n    }\n    return out;\n  }\n}; //end of list class\n```\nLIMIT FRIENDSHIPS lol.\n\nWe can do the same thing for vectors:\n```cpp\nclass vector{\n  int *theVector;\n  size_t n, cap;\n  public:\n    ...\n    class iterator{\n      int *p;\n      ...\n    };\n    class const_iterator{\n      ...\n    };\n    iterator begin(){return iterator{theVector};}\n    iterator end(){return iterator{theVector+n};}\n    const iterator begin/end //similar\n}\n```\n\n## OR\n```cpp\nclass vector\n...\n  public:\n    typedef int *iterator; //using iterator = int*\n    typedef const int *onst_iterator; //using const_iterator= const int*;\n    ...\n    iterator begin(){return theVector;}\n    iterator end(){return theVector+n;}\n```\n\n\n","tags":[],"folderPathname":"/CS246E","data":{},"createdAt":"2019-09-26T14:17:30.381Z","updatedAt":"2019-12-05T01:36:45.596Z","trashed":false,"_rev":"HW6U7m2QrrM"}