createdAt: "2019-12-03T15:47:16.847Z"
updatedAt: "2019-12-03T16:20:01.160Z"
type: "MARKDOWN_NOTE"
folder: "13f1477d1dab07e879ca"
title: "Problem 33 - I want a smaller vector class"
tags: []
content: '''
  ## Problem 33 - I want a smaller vector class
  
  Currently, vector/vector_base have an allocator field.
  The allocator field is stateless - has no fields. What is its size? It's not 0 - **C++ forbids it**. It doesn't make sense and screws up all the math. So **all sizes are >= 1**;
  
  Practically - compiler places a dummy char inside allocator. So having an allocator as a field makes the vector larger by a byte. One byte. It doesn't sound like much, but **alignment** might allocate 8 bytes or 4 bytes to **get the pointer field to land on an address divisible by 4 or 8**.
  
  To save this space, C++ provides the **empty base optimization (EBO)**. Under EBO, an empty base class does not have to occupy space in an object.
  !!! note Newer versions
  This is fixed in newer versions of C++. We don't have this problem in newer versions.
  !!!
  
  So we can eliminate the space cost of an allocator by making it a base class. At the same time, we can make vector_base a base class of vector.
  
  ```cpp
  template<typename T, typename Alloc = allocator<T>>
  struct vector_base : Alloc{
    size_t n, cap;
    T *v;
    using Alloc::allocate; //Because Alloc is a template arg, we don't know what it looks like.
    using Alloc::deallocate; //So if we want to use inherited members, we need using declarations to make them visible.
    
    //etc
    
    vector_base(size_t n):n{0}, cap{n}, v{allocate(n)}{}
    ~vector_base(){deallocate(v,n);}
  };
  ```
  
  ```cpp
  //private inheritance, no is-a
  template<typename T, typename Alloc=allocator<T>> class vector: vector_base<T,Alloc>{
    using vector_base<T,Alloc>::n;
    using vector_base<T, Alloc>::cap;
    using vector_base<T, ALloc>::v; //same reason as above
    using Alloc::allocate;
    
    //etc
    
    public:
      // use n, cap, u instead of vb.n, vb.cap, vb.v
  }
  ```
  Private inheritance is used because this class isn't a special allocator. 
  
  uninitialized_copy, etc - need to call construct/ destroy
  simplest - let them take allocator as param
  
  ```cpp
  template<typename T, typename Alloc>
  void uninitialized_fill(T *start, T*finish, const T&x, Alloc a){
    ~~~~
      a.construct(~~~~);
      ~~~~~
      a.destroy(~~~~~);
    ~~~~~~~
  }
  ```
  
  But how can vector pass an allocator to these functions?
  
  ```cpp
  uninitialized_fill(u, v+n, i, static_cast<Alloc &> (*this)); //cast yourself to base class reference.
  ```
  But this doesn't work, because the children of vector_base don't know it's an alloc!
  
  So we have to use **protected inheritance** - my children can know my parent class but nobody else.
  
  So above, we now have
  ```
  struct vector_base: protected Alloc{}
  ```
  
  ### Final words
  
  The goal of this course is abstraction. C++ is the king of abstractions. Abstractions have tradeoffs, and it depends on your client. Hopefully now you know how to create amazing abstractions that are high level, but have extremely fine-grain control. What is the client going to do? It's hard to come up with a language that can get extreme efficiency but can also have a pleasant interface.
'''
linesHighlighted: []
isStarred: false
isTrashed: false
