{"_id":"note:X0AqYwpp3N_","title":"Problem 30: Total Control","content":"## Problem 30: Total Control\n\nC++ lets you control pretty much everything.\n\nWhy not go the rest of the way and take control over memory allocation?\nMemory allocators are tricky to write, of course.\n\nSo why would you want to?\n* the built-in one is too slow\n  * The built-in one is to general-purpose\n    * eg if you know you will always allocate objects of the same size, a custom allocator may perform better.\n  * you want to optimize locality\n    * maybe you want a seperate heap just for objects of some class C.\n    * keeps objects closer to one another, and improves cache performance\n  * you want to use \"special memory\"\n    * maybe you want to put your objects in shared memory, where other programs can see them.\n  * you want to profile your program\n    * maybe you just want to collect stats on your program's allocation patterns, so you can decide whether further optimization is required.\n\nWe'll focus on the last one for now.\n\nHow do you customize allocaton? Well, you overload operator `new`. If you define a glabel non-member operator new, all allocations in your program will use your allocator.\nYou'll also have to write operator delete, or else it's undefined behaviour.\n\n```cpp\nvoid *operator new(size_t size){\n  cout << \"Request for \"<< size << \"bytes\" << endl;\n  return malloc *(size);\n}\nvoid operator delete(void *p){\n  cout << \"Freeing\"<<p<< endl;\n  free(p);\n}\n```\nThe above works, but it's not correct. It doesn't adhere to convention in terms of exeption safety.\nIf operator new fails, it it supposed to throw `bad_alloc`.\n\nActually, if operator new fails, it is supposed to call the function `new_handler`.\nThe new_handler function can:\n* free up space (somehow)\n* install a different new handler/deinstall the current\n* throw bad_alloc\n* abort/exit\n\nnew_handler should be called in an infinite loop. If new_handler is nullptr, operator new throws. Also, new must return a valid pointer if size ==0, and delete nullptr must be safe.\n\nSo here's the correct implementation:\n```cpp\n#include <new>\nvoid *operator new(size_t size){\n  cout <<\" Request for \" << size << \"bytes\" << endl;\n  if(size == 0 ) size = 1;\n  while(true){\n    void *p = malloc(size);\n    if(p) return p;\n    std::new_handler h = std::get_new_allocator();\n    if(h) h();\n    else throw std::bad_alloc{};\n  }\n}\n\nvoid operator delete(void *p){\n  if(p ==nullptr) returnl //ez clap\n  cout << \"Deleting \"<< p <<endl;\n  free(p);\n}\n```\n\nReplacing global operator new/operator delete affects your whole program.\nMore likely, you want to replace these operators on a class by class basis, especially if you are writing allocators specifically tuned to the sizes of your objects.\n\nTo do this, define operator new/operator delete with your classes. They **must** be static members\n\n```cpp\nclass C{\npublic:\n  static void *operator new(size_t size){\n    cout << \"Running class C's allocator\" << endl;\n    return ::operator new(size); //means global, if there's nothing in front of the double ::\n  }\n  static void operator delete(void *p) noexcept{\n    cout << \"Freeing\" << p << endl;\n    return ::operator delete(p);\n  }\n};\n\nclass C{\n  public:\n    static void *operator new(size_t size, std::ostream &out){\n      out << ~~~~~~~~~ << endl;\n      return ::operator new(size);\n    }\n};\n\nC *x = new (cout) C; //log to cout\nofstream f{\"filename.txt\"};\nC * y = new (f) C;\n```\n\nMust also write specialized delete:\n```cpp\nclass C{\n  public: ...\n  static void operator delete (doid *p, std::ostream &out) no except{\n    out << \"Special delete: \" << p << endl;\n    return ::operator delete(p);\n  }\n};\n```\n\nThis won't compile, because you also have to write ordinary delete. We've already written it before.\n\n```cpp\nC * p = new (f) C; //running C's allocator...\n\ndelete p; //ordinary delete (uses cout)\n```\nThere needs to be an ordinary delete as well.\n\nSpecial operator delete will only occur in one case: the constructor when you call special new could throw, in which case the special operator delete will run. If there isn't one, no delete gets called => leak. This is the only case. You can't call it yourself. \n\nExample:\n```cpp\nclass C{\n~~~~\n  public:\n  ~~~~\n  C(bool b){if(b) throw 0;}\n};\n~~~~~\ntry{\n  C *p=new(cout) C (true); //throws - specialized operator delete is called automatically.\n  delete p; //not reached\n}catch(...){}\n\nC*q = new (cout) C (false); //does not throw\ndelete q; //ordinary operator delete.\n```\n\nCustomizing array allocation: overload operator new[] and operator delete[].","tags":[],"folderPathname":"/imported/CS246E","data":{},"createdAt":"2019-11-27T17:36:58.124Z","updatedAt":"2019-11-28T15:09:11.584Z","trashed":true,"_rev":"os4yLWDE-i8"}