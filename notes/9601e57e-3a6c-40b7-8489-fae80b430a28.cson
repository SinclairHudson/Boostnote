createdAt: "2019-11-19T15:31:06.153Z"
updatedAt: "2019-11-20T17:59:53.436Z"
type: "MARKDOWN_NOTE"
folder: "13f1477d1dab07e879ca"
title: "Problem 24: Abstraction over Iterators"
tags: []
content: '''
  ## Problem 24: Abstraction over Iterators
  
  I want to jump ahead **n** steps in my iterator.
  
  ```cpp
  template <typename Iter> Iter advance(Iter it, size_t n){
    for(size_t i = 0; i < n; ++i) ++it;
    return it;
  }
  ```
  Ez clap. But it's slow... it runs in $O(n)$.
  
  #### Can we jump ahead quickly?
  It depends on what you're iterating over. For vectors, yes of course. The iterators are just pointers. For lists, you have to take n steps of length 1.
  
  #### Can we go backwards?
  For vectors, yes.
  for singly linked lists? no.
  
  All iterators support !=. *, ++. Some iterators support other operations.
  
  `list::iterator` - called a **forward iterator**: it can only go one step forward.
  
  `vector::iterator` - called a **random access iterator**: can go anywhere. Arbitrary pointer arithmetic.
  
  How ca we write advance to use `+=` for random access iterators and loop for forward iterators?
  
  Since we have different kinds of iterators, let's create a type hierarchy:
  ```cpp
  struct input_iterator_tag{};
  struct forward_iterator_tag: public input_iterator_tag{};
  struct bidirectional_iterator_tag: public forward_iterator_tag{};
  struct random_access_iterator_tag: public bidirectional_iterator_tag{};
  ```
  
  To associate each iterator class with a tag - could use inheritance:
  
  ```cpp
  class List{
  ~~~
  public:
    class iterator: public forward_iterator_tag{~~~~};
  }
  ```
  
  However, it makes it hard to ask what kind of iterator we have. We can't dynamic cast with no vtables.
  Doesn't work for iterators that aren't classes.
  Instead, make the tage a member:
  ```cpp
  class List{
  ~~~
  public:
    class iterator{
    ~~~
    public:
    using iterator_category = forward_iterator_tag; //this will be the convention
    // every iterator class will define a type member called iterator_category.
    ~~~
    };
  };
  ```
  But this also doesn't work for iterators that aren't classes. But we aren't done yet. We can make a template that associates every iterator type with its category:
  ```cpp
  template<typenmae It> struct iterator_traits{
    typedef typename It::iterator_category iterator_category; //why typename?
  }
  ```
  #### Why typename?
  It's needed so that C++ knows that It::iterator_category is a type. Remember, the compiler knows nothing about `It`.
  
  Consider:
  ```cpp
  template<typename T> void f(){
    T::something a; //only makes sense if T::something is a type.
  }
  ```
  
  Also consider:
  ```cpp
  template<typename T> void f(){
    T::something *x; //is that a pointer declaration, or a multiplication? You can't tell unless you know that T::something is a type. C++ assumes value instead of type. 
  }
  ```
  So it has to be:
  ```cpp
  template<typename T> void f(){
    typename T::something *x;
  }
  ```
  
  You need to say typename whenever you refer to a member type of a template parameter. 
  
  ---
  Back to iterator_traits.
  
  `iterator_traits<List<T>::iterator>::iterator_category` will give forward_iterator_tag.
  
  Provide a specialized version for ptrs.
  
  ```cpp
  template<typename T> struct iterator_traits<T*>{
    typedef random_access_iterator_tag iterator_category;
  };`
  ```
  for any iterator type T, `iterator_traits<T>::iterator_category` resolves to the tag struct for T. (including if T is a pointer).
  
  What do we do with it?
  
  Want:
  ```cpp
  template<typename It> It advance(It it, int n){
    if(typeid(iterator_traits<It>::iterator_category)= typeid(random_access_iterator_tag)){
      return it+=n;
    }
    else if(~~~){
    ~~~
    }
  }
  
  ```
  If the iterator is not random access, and therefore doesn't have a += operator, `it +=n` won't compile. Even though it will never be used. Moreover, the choice of which impl to use is being made at run-time, when the right choice is known at compile-time.
  
  We need a compile-time decision: **overloading**.
  
  For any iterator type T, `iterator_traits<T>::iterator_category` resolves to the tag struct for T (incl if T is a ptr)
  ```cpp
  template<typename Iter> Iter doAdvance(Iter it, int n, random_access_iterator_tag){
    return it += n;
  }
  template<typename Iter> Iter doAdvance(Iter it, int n, bidirectional_iterator_tag){
  if(n>o){
    for(int i= 0; i < n; ++i){
      ++it
      }
  }
  else if(n< 0) {for(int i = 0; i < -n; ++i) --it;}
  return it;
  }
  
  template<typename Iter> Iter doAdvance(Iter it, int n, forward_iterator_tag){
    if(n >= 0){
      for(int i = 0; i < n; ++i) ++i;
      return it;
    }
    throw SomeError{};
  }
  ```
  Finally, create a wrapper function to select the right overload:
  
  ```cpp
  template <typename Iter> Iter advance (Iter it, int n){
    return doAdvance(it, n, iterator_traits<Iter>::iterator_category{});
  }
  ```
  Now, the compiler will select the fast doAdvance for random access iterators, the slow doAdvance for bidirectionalad iterators, and the throwing doAdvacnce for forward iterators.
  This is all decided at compile-time, so there's no cost to runtime efficiency.
  Using template instantiations to perform compile-time computation is what's called **template meta-programming**.
  
  C++ templates form a **functional language** that operates at the level of types. They're **Turing Complete**. Bruh.
  Express conditions via overloading, repetition via recursive template instantiation.
  ```cpp
  template <int N> struct Fact{
    static const int value = N * Fact<N-1>::value;
  };
  
  template <> struct Fact<0>{
    static const int value = 1;
  };
  
  int x = Fact<5>::value; //120 - evaluated at compile-time.
  ```
  
  But for compile-time computation of values, C++ 11/14 offer a more straightforward facility.
  
  ```cpp
  constexpr int fact(int n){ //constexpr functions mean
    if(n==0) return 1;      //evaluate this at compile-time if n is a compile-time constant
    return n*fact(n-1);     //else evaluate at run-time.
  }
  ```
  
  A constexpr function must be something that actually can be evaluated at compile-time.
  * can't be virtual, of course
  * can't mutate non-local variables.
'''
linesHighlighted: [
  125
]
isStarred: false
isTrashed: false
