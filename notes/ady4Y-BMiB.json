{"_id":"note:ady4Y-BMiB","title":"Problem 13 - Less copying","content":"## Problem 13 - Less copying\n\nBefore:\n```cpp\nvoid push_back(int n);\n```\nNow:\n```cpp\n              //(1)\nvoid push_back(T x){ //if T is an object, how many times is T being copied? \n  increateCap();\n  new (theVector + (n++)) T(x);\n                        //(2)\n}\n```\n\nIf arg is an lvalue: (1) is a copy constructor, (2) is a copy constructor\n\nIf arg is an rvalue (1) is a move constructor, (2) is a copy constructor\n\nFix:\n```cpp\nvoid pushback (T x){\n  increaseCap();\n  new (theVector +(n++)) T (std::move(x));\n  //x will still be a valid object, but unspecified contents.\n}\n```\nlvalue: copy + move\nrvalue: move + move\n\nUnless, of course, T doesn't have a move constructor. Then it's still 2 copies.\n\nBetter Fix: Take x by ref.\n\n```cpp\nvoid push_back(const T &x){\n  increaseCap();\n  new (theVector + (n++)) T(x); //copy ctor\n}\nvoid push_back(T &&x){\n  increaseCap();\n  new (theVector + (n++)) T(std::move(x));\n}\n```\nl-values: 1 copy\nr-values: 1 move\nno move constructor: 1 copy\n\nConsider:\n```cpp\nvector<Posn> v;\nv.push_back(Posn{3,4});\n```\n1. Constructor call to create the object\n2. Copy of move construction into the vector (depending on whether Posn has a move constructor)\n3. Destructor call on temporary object.\n\nWe could eliminate 1 and 3 if we could make vector build the object.\nPass constructor args to the vector, not the actual object.\n\nBut how do we do this?\n\n---\nA note on template functions.\nConsider `std::swap`. It works on all types? Swap is a **template function**.\nImplementation:\n```cpp\ntemplate<typename T>  void swap(T &a, T&b){\n  T tmp (std::move(a));\n  a = std::move(b);\n  b = std::move(tmp);\n}\nint x = 1, y = 2;\nswap(x,y); // Equiv swap<int>(x,y)\n```\nBut you do not have to say `swap<int>`. C++ can deduce this from the types of x and y, like auto.\n\n---\nBack to vector - passing constructor arguments.\nWe don't know what types the constructor arguments should have?\nT could be any class, it could have several constructors.\n\nIdea: write a member template function, like swap.\n\nOk, but how many constructor arguments?\n\n**variadic templates**\n```cpp\ntemplate <typename T> class vector{\n~~~~~\n  public:\n    ~~~~              //vv this ... is meant\n    template<typename ... Args> void emplace_back(Args... args){\n      increaseCap();\n      new (theVector+(n++)) T (args...);\n      \n    }\n};\n```\n`Args` is a sequence of type variables, denoting the types of the actual arguments of `emplace_back`.\n`args` is a sequence of program variables denoting the actual arguments of `emplace_back`.\n```cpp\nvector<Posn> v;\nv.emplace_back(3,4)\n```\n\nProblem: the args are being taken by value. That means copying. So can we take args by reference instead? But what kind of reference? lvalue, rvalue, or a mix of both?\n```cpp\n//back in the templace of class vector.\ntemplate<typename ... Args> void emplace_back(Args &&... args){\n  increaseCap();\n  new (theVector + (n++)) T(args...);\n}\n```\nThere are sepecial rules happening here: `Args &&` is a **forwarding reference**. (or universal reference)\nSo it can refer to either an rvalue or an lvalue.\n\nWhen is a reference universal?\n1. Must have the form T&&, where T is the type argument being deduced for the current template function call.\n\nExamples:\n```cpp\ntemplate <typename T> class C{\n  public:\n    template <typename U> void f(U&& x); //universal\n    template <typename U> void g(const U&& x); //not universal\n    void h(T&& x); //not universal. Nothing's being deduced.\n}\n```\nRecall\n```cpp\nclass C{...};\nvoid f(C &&x){ //rvalue ref - x points to an rvalue, but x _is_ an lvalue.\n   g(x); //x will be passed as an lvalue to g.\n}\n```\nIf you want to preserve the fact that x is an rvalue ref, so that a \"moving\" version of g is called:\n```cpp\nvoid f(c&&x){\n  g(std::move(x));\n}\n```\nBut now it's a little different. In the case of args, we don't know if they're lvalues or rvalues.\nWant to call move on the args _iff_ the original arguments are rvalues.\n\n```cpp\ntemplate<typename...Args> void emplace_back(Args&&...args){\n  increaseCap();\n  new (theVector + (n++))T(std::forward<Args>(args)...); //calls std::move iff arg is an rvalue ref. else does nothing.\n}\n```\nNow args is passed to T's constructor with lvalue/rvalue information preserved.\nThis is called **perfect forwarding**.","tags":[],"folderPathname":"/CS246E","data":{},"createdAt":"2019-10-03T15:11:05.740Z","updatedAt":"2019-12-05T02:12:03.065Z","trashed":false,"_rev":"L1rcMZkDiK"}