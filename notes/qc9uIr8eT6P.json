{"_id":"note:qc9uIr8eT6P","title":"Week 11: Virtual Memory","content":"# Week 11: Virtual Memory\n\nWe're focusing on the connection between cache and disk now.\n\nHow does a single processor run two processes at the same time?\n\nWell it doesn't actually, it just looks like it does that. It loads some of program 1, executes that, then executes some of program 2, and executes that. It loads page at a time. It saves the state of the programs before it gets flushed from the CPU. We're swapping in and swapping out.\n\nPrograms are stored on the disk in **pages**. The page size is generally $4KB$. That's a lot, because going to disk is very slow.\n\nVirtual memory is the **organizing relationship between RAM and disk.**\nEvery program thinks it has unlimited memory. Of course, it does not.\n\nWe use RAM of 4GB, which means and address space of 32 bits.\n\nRemember, every program thinks it starts at address 0, but it has a different physical address in main memory.\n\nSomeone has to tell the CPU where in physical memory where the data it needs is. Who keeps track of the mapping of programs in physical memory?\n\nThe **Page Table** is this mapping. It translates virtual addresses to physical addresses.\n\nThere's a dedicated spot in main memory where the page tables are stored. Each program has a page table.\n\nThe processor has a **page table register** which is a pointer to the page table for the current program.\n\n![e3f6188a.png](e3f6188a-kl2ssw8m.png)\n\nWhat if the virtual page doesn't exist in main memory yet? This is called a **page fault**. So we have to fetch it from disk.\n\nVirtual addresses of pages can point to disk or RAM. There's a **valid bit** in the page table, that tells us if the page is in physical RAM or if it's on disk.\nIf the valid bit is 0, the rest of the data in that entry is meaningless.\n\n![d86ca630.png](d86ca630-kl2ssw8m.png)\n\nPages are copied from disk to RAM. It's always a copy down.\n\nSo, when doing a lookup for a virtual page number, you will always find the entry in the page table. However, it may be invalid.\n\n\nA virtual address is comprised of two parts: $VPN: Offset$. So $0:016$ would be an offset of 16 from the start of the physical page that was found in the page table.\n\nAn offset into the page is normally 12 bits.\n\n![ec9b24cf.png](ec9b24cf-kl2ssw8m.png)\n\n\nWe've been living in virtual addresses up to this point.\n\nWe use the same \"dirty bit\" system for pages in between RAM and disk.\n\n!!! question What if my page table is absolutely massive? Like my program has 5000 pages to it?\nYou can actually page the page table itself. This is like a multi-level page table.\n!!!\n\nThe offset does not have to be a multiple of 4 or 8.\n\n---\n\nWe can optimize by caching parts of the cache table.\n\nThis cache is called the **TLB**.\n\n![5f46680c.png](5f46680c-kl2ssw8l.png)\n\nThe parent of the TLB is the page table.\n\nThe TLB contains the popular pages. These pages are only in RAM, because they're popular. When a page goes back to disk, it gets removed from the TLB (invalid).\n\n![0e0f0c24.png](0e0f0c24-kl2ssw8l.png)\n\nDotted lines are misses, and solid lines are what you check first.\n\n---\n\nThere's a control flow:\n```\nPC has a virtual address\nif(TLB hit on the virtual address){\n  we have the PA, and it's either in cache or RAM\n  if(cache hit on PA){\n    best case scenario, we have the data. Done.\n  }\n  else(cache miss){\n    grab data from RAM, using the PA. Done, ez.\n    Update Cache, since this was just used.\n  }\n}\nelse(TLB miss){\n  go to page table\n  if(Page table HIT){\n    we have a PA now.\n    if(cache hit on PA){ //use the index bits in the PA now, to find.\n      We have a good, updated version. EZ.\n      update TLB.\n    }\n    else(cache miss on PA){\n      Grab from RAM. We're guaranteed to find it because it was in the PT.\n      Update both TLB and CACHE (they were both misses.)\n    }\n  }\n  else(Page table MISS){\n    This is a page fault.\n    We need to go to disk, and bring it to RAM. This potentially removes a page\n    from RAM, potentially writing an updated version to disk. \n    When a page is removed in RAM, it is also removed in cache and TLB.\n    In this case, we also have to update the Page Table and TLB, to keep it up to date.\n  }\n}\n```\n\n![b8543c6b.png](b8543c6b-kl2sswac.png)\n\n7 is possible.\n\n---\n\nAddresses are in HEX.\nThere's a row for every single virtual page in the page table.\nThey're indexed by the virtual page numbers. so VP 6's entry in the page table it at row 6.\nThe TLB is not organized like this; it's random.\n\n![c5395c7b.png](c5395c7b-kl2ssw8l.png)\n\nWe fill prages in RAM from the bottom up.\n\nThis video, Week 11: PageTable_TLB goes over the process of a ton of LDUR instructions and how the TLB and PT work.\n\nThere's a special reference bit per address. The OS checks the reference bit to know which entry to kick out. Every 1000cc or something, an external controller finds entries that haven't been used in a while and purges them so that new pages can be loaded in.\nWe just have to worry about turning on the reference bits when we use that entry. We have to update this bit in both the PT and TLB.\nThere's probably an extra controller that syncs reference bits from TLB to PT, so the current process doesn't have to halt.\n\n\nSTUR is unique in that it writes to data cache. We turn on the dirty bit, so when the entry is cleared it knows to write that data from cache back to RAM or RAM back to disk (in that order).\n\nWhen you evict from the TLB, you don't evict from the PT or the actual data in RAM. Also, you go top-down and evict the one that doesn't have a reference bit of 1 first. That's because it wasn't referenced recently.\n\nWhen you evict from RAM, you also need to evict from TLB and CACHE and the PT. If there's a dirty bit, these are write-backs, from cache to RAM to disk. 2 levels of dirty bits, 2 writebacks.\n\n---\n\nWhen there are multiple programs, they switch between them (time slicing), doing parts of program 1 then program 2 then program 1 ... each program is called a process.\n\nWhen switching, we save some of the state of the cpu.\nWe save the **PC** of where we left off.\nWe also need to store the **register file**.\n\nThe swap space is very close to the datapath, and it's where other states are stored for the different processes.\n\n\n\n","tags":[],"folderPathname":"/imported/CS251","data":{},"createdAt":"2020-07-24T18:47:21.681Z","updatedAt":"2020-08-14T19:21:41.093Z","trashed":true,"_rev":"k4lhWj9U_MU"}