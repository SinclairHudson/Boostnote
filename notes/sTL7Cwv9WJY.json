{"_id":"note:sTL7Cwv9WJY","title":"Problem 02: Linear Collections and Modularity","content":"## Problem 02: Linear Collections and Modularity\nLet's make a linked list structure!\n\n#### node.h\n```cpp\nstruct Node{\n  int data;\n  Node *next;\n};\n\nsize_t size(Node *n); //function\n```\n#### node.cc\n```cpp\n#include \"node.h\"\n\nsize_t size(Node *n){\n  size_t count = 0;\n  for()Node *cur=n; cur; cur = cur->next){\n    count++;\n  }\n  return count;\n}\n```\nAnd now we can use this module in main.\n#### main.cc\n```cpp\n#include \"node.h\"\n\nint main(){\n  Node *n = new Node;\n  n->data = 3;\n  n->next = nullptr;\n  \n  Node *n2 = new Node{2, n};\n  Node *n3 = new Node{4, new Node{5, nullptr}};\n  \n  delete n; //ok\n  delete n2; //ok\n  delete n3->next;\n  delete n3;\n  \n  // alternatively,\n  while(n3){ //procedurally deletes all nodes in a linked list.\n    Node *tmp = n3;\n    n3 = n3->next;\n    delete tmp;\n  }\n}\n```\n\n---\n\nWhat happens if we do\n```cpp\n#include \"node.h\"\n#include \"node.h\"\n```\n**This won't compile**, because we're inserting the definition twice. We're defining the same struct twice, and that isn't allowed. \n\n### C Preprocessor\n\nThe C preprocessor is a program that transforms code before handing it off to the **compiler**.\nIt's responisble for `#include` statements. `#` signifies a preprocessor command.\n\nYou can also do things like\n`#define VAR VALUE`, which literally just replaces every instance of `VAR` with `VALUE`.\nSo you could do something like\n```cpp\n#define MAX 10;\n......\nint main(){\n  int x[MAX];\n}\n```\nAnd this would compile. \nYou can even talk to the preprocessor through the command line.\n```\n$ g++14 -D MAX=10 myprogram.cc -o exec\n```\nThe above command will accomplish the same thing as `#define MAX 10;`.\n\nWe can use the C Preprocessor to solve our above problem of including the same file twice. This problem could come up in complex problems, where two linked files both need access to node.h.\n\n#### node.h\n```cpp\n#ifndef NODE_H // this is true if NODE_H is not defined.\n#define NODE_H // define NODE_H\n ... actual file contents go here\n ....\n#endif\n```\nThe **include guard** allows us to include the same module twice, because it'll simply get ignored on the second pass.\n\n!!! note Include Guards\nAlways put include guards in header files. There's no reason not to, and will save you from **linking errors**.\n!!!\n\n!!! danger Compiling header files\nNEVER compile a .h file. It doesn't make sense. Just include them in source files and compile those.\n!!!\n\n!!! danger Including source files\nNEVER include a .cc or .cpp file. You don't need to, and it makes linking way more confusing. \n!!!\n\nNow, what if you have two structures that have the same name, but are different? A good example would be a Node struct from a linked list and a Node struct from a binary tree. The solution, as you may have guessed, is **namespaces**:\n\n#### list.h\n```cpp\n#ifndef LIST_H\n#define LIST_H\n\nnamespace List{\n  struct Node{\n    int data;\n    Node *next;\n  };\n  ...\n}\n#endif\n```\n\n#### tree.h\n```cpp\n#ifndef TREE_H\n#define TREE_H\n\nnamespace Tree{\n  struct Node{\n    int data;\n    Node *left;\n    Node *right;\n  };\n  ...\n}\n#endif\n```\n\n#### main.cc\n```cpp\n#include \"list.h\";\n#include \"tree.h\"; //ok\n\nint main(){\n  List::Node *ln = new List::Node{1,nullptr};\n  Tree::Node *tn = new Tree::Node{1,nullptr,nullptr};\n  \n  ...\n  delete ln;\n}\n```\n\n!!! note Namespaces\nNamespaces are **open**. This means that anyone can add functions to any namespace. The only exception is the `std` namespace.\n!!!\n\n!!! note Unnamed Namespaces\nThere's a weird trick with unnamed namespaces; they're private. Nobody outside the namespace can explicitly call functions in an unnamed namespace. However, these methods can still be used through other methods. We'll see an example in the next problem.\n!!!","tags":[],"folderPathname":"/CS246E","data":{},"createdAt":"2019-10-27T20:10:27.153Z","updatedAt":"2019-12-04T21:40:41.139Z","trashed":false,"_rev":"SeaWvzfOFyP"}