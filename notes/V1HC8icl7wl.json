{"_id":"note:V1HC8icl7wl","title":"Problem 15: Is vector exception safe?","content":"## Problem 15: Is vector exception safe?\n\nConsider:\n```cpp\ntemplate <typename T> class vector{\n  size_t n, cap;\n  T *theVector;\n  public: //assume n > 0\n    vector(size_t n, const T&x):n{n},cap{n},\n    theVEctor{static_cast<T*> operator new(n *sizeof(T))}{\n      for size_t i = 0; i < n; ++i){\n        new (theVector +i) T(x); //copy ctor - what if it throws?\n      }\n      ...\n}\n```\nIf that copy constructor throws, then we have a partially constructed vector, the destrcutor will not run. But then, all the T elements and the array will not be deleted. That's a broken invariant, since it doesn't contain n valid T objects.\n\n!!! note `new` throwing\nIf operator `new` throws, nothing has been allocated, so there's actually no problem. Strong guarantee.\n!!!\n\nLe fix:\n```cpp\ntemplate<typename T> vector<T>::vector(size_t n , const T&x):n{n}, cap{n},theVector{~~~~~~~~~~~~~~~~~~~~}{\n  size_t progress = 0;\n  try{\n    for(progress = 0; progress<n; ++progress){\n      new (theVector + progress) T(x);\n    }\n  }   // catch ALL. catch anything\n  catch(...){\n    for(size_t i=progress; i>0; --i) theVector[i-1].~T();\n    operator delete(theVector);\n    //we need to re-throw\n    throw;\n  }\n}\n```\nNow we need to abstract the filling part into its own function:\n```cpp\ntemplate<typename T> void uninitialized_fill(T *start, T *finish, const T&x){\n  T *p;\n  try{\n    for (p=start; p!=finish; ++p){\n      new (p) T(x);\n    }\n  }\n  catch(...){\n    for(T *q=p; q!=start; --q) (q-1)->~T();\n    throw;\n  }\n} \n```\n```cpp\ntemplate<typename T>vector<T>::vectorrr(size_t n, const T &x):n{n},cap{n}, theVector{static_cast<T*>(operator new (n *sizeof(T)))}{\n  try{\n    uninitialized_fill(theVector, theVector+n, x); //strong guarantee\n  }\n  catch(...){\n    operator delete(theVector);\n    throw;\n  }\n}\n```\nWe can clean this up by doing RAII on the array:\n```cpp\ntemplate<typename T> struct vector_base{\n  T *v;\n  size_t n, cap;\n  vector_base(size_t n):v{static_cast<T*> (operator new(n*sizeof(T)))},n{n},cap{n}{}\n  ~vector_base(){operator delete(v);}\n};\n```\n```cpp\ntemplate<typename T> class vector{\n  vector_base<T> vb; //cleaned up implicitly when vector is destroyed.\n  public:\n    vector(size_t n, const T&x): vb{n}{\n      uninitialized_fill(vb.v,vb.v+vb.cap,x);\n      vb.n = vb.cap;\n    }\n    ~vector(){destroy_elements();}\n    ...\n}\n```\nThere's no try block, but it is exception safe.\n\nBut that was just one constructor... vector has many.\n```cpp\ntemplate<typename T> vector<T>::vector(const vector &other):vb{other.size}{ //similar to uninitialized_fill (MIDTERM)\n  uninitialized_copy(other.begin(), other.end(), vb.v);\n  vb.n=vb.cap; \n}\n```\n\nAssignment - copy and swap are exception safe, as long as swap is no-throw.\n\npush_back:\n```cpp\nvoid push_back(const T&x){\n  increaseCap(); //and what if increaseCap fails?\n  new(vb.v+vb.n) T(x); //don't increment n before you know the construction has succeeded.\n  //and if T(x) throws, we still have the same vector. so it's safe.\n  ++vb.n;\n}\n```\n```cpp\nvoid increaseCap(){\n  if(vb.n==vb.vb.vap){\n    vector_base<T> vb2{2*vb.cap};\n    uninitialized_copy(vb.v,vb.v+vb.n,vb2.v); //strong guarantee\n    destroy_elements(); //nothrow\n    std::swap(vb,vb2); //swap is nothrow on ints and pointers\n  }\n}\n```\nAnd the only try blocks we've done are in uninitialized_fill and uninitialized_copy. \n\n##### This works, but we have an efficiency issue\n\nWith copying from the old array to the new one. We should be moving instead of copying.\nBut if we're moving, then we don't have the old array to fall back on.\nMoving ruins the old array, so if an  exception is thrown during moving, our old vector is not intact. We can only move if we are sure that the move operation is **no-throw**.\n```cpp\nvoid increaseCap(){\n  if(vb.n==vb.vb.vap){\n    vector_base<T> vb2{2*vb.cap};\n    uninitialized_copy_or_move(vb.v,vb.v+vb.n,vb2.v); //strong guarantee\n    destroy_elements(); //nothrow\n    std::swap(vb,vb2); //swap is nothrow on ints and pointers\n  }\n}\n```\n```cpp\ntemplate <typenmae T> void uninitialized_copy_or_move(T *start, T *finish, T *target){\n  T *p;\n  try{\n    for(p=start;p != finish, ++p, ++target){\n      new(target) T (std::move_if_noexcept(p)); //produces std::move(x) if x has a non-throwing move ctor\n      //produces x otherwise.\n    }\n  }\n  catch(...){\n   //omitted.\n  }\n}\n```\nYou have to tell the compilter that T's move ctor is non-throwing. \ntag it like this: `C (C &&other) noexcept;`\nDon't lie with noexcept!\n\nIn general: moves & swaps should be non-throwing. Declare them so, which will allow more optimized code to run. Any function that you are sure will never have to throw or propagate an exception, you should declare `noexcept`.\n\nQ: Is `std::swap` noexcept?\n```cpp\ntemplate<typename T> void swap(T &a, T &b){\n  T c(std::move(a));\n  a = std::move(b);\n  b = std::move(c);\n}\n```\nA: Only if T has nothrow move constructor or move assignment. So how do we specify this?\n\n```cpp\ntemplate<typename T> void swap(T &a, T &b)\nnoexcept(std::is_nothrow_move_constructable<T>::value && //oh lawd\n        std::is_nothrow_move_assignable<T>::value){ //just a boolean condition  \n  T c(std::move(a));\n  a = std::move(b);\n  b = std::move(c);\n}\n```\n","tags":[],"folderPathname":"/imported/CS246E","data":{},"createdAt":"2019-10-10T14:30:30.716Z","updatedAt":"2019-10-31T20:14:26.944Z","trashed":true,"_rev":"EqI4SqIoaxc"}