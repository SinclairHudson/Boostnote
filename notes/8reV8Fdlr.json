{"title":"L5: ","content":"\nwhere you're accessing a variable, there's a **critical section**. We want mutual exclusion access to every shared variable.\n\nRace conditions are **VERY hard** to debug and find. The linux kernel, at any time, might just have 300 race conditions at any given time.\n\n\n```mips\nll # gets value at the address now\nsc # stores a value at the addr if the value at the addr has not changed since ll.\n\nx = value at address sd  # this is the ll instruction\n\nif x == *sd:\n    *sd = 1  # I want the lock. It doesn't mean I have the lock, but I want it.\n    y = success\n \nelif x != *sd:\n    y = failure\n```\n\nso now, after this, we have a few cases:\n\n* if `y == success`:\n    1. if `x == False`, return false, stop spinning. We own the lock!\n    2. if `x == True`, the lock was already not available, return true, keep spinning.\n    \n* if `y == failure`, return true, keep spinning, no lock!\n\nwe can't make the assumtion that it was true, and it changed, therefore it must be false. we use integers to represent, so it could be 1 (true), and then 350 (also true).\n\nTODO check piazza post for flow chart of the above.\n\n# Spinlock problems\nWe're ignoring interrupts while we have the lock. They're **good for small critical sections**.\n\nWe want a lock that **blocks**. You show up at the DC bathroom, see that it's locked, and then you just fall asleep on the floor. You're not wasting resources knocking. \nAnd when someone comes out of the bathroom, they open the door and wake you up.\n\n![](image-kke4m5fe.png)\n\n![](image-kke4n95a.png)\n\nwe have a wait queue for every thing you could wait on. One wait channel per resource.\n\n![](image-kke4tz88.png)\n\nThese are atomic, but wchan_sleep is complicated.\nWeight channels are **HIGHLY specific**.\n\n![](image-kke50xvk.png)\n\n:::danger Never go to sleep when you're holding resources\n:::\n\nIf you are in the bathroom stall, and you fall asleep, you can never unlock it. You're asleep forever.\n\n![](image-kke5e988.png)\n\nWe only wake one when we release the lock, because if we woke all, 99% of them would just go back to sleep.\n\n![](image-kke5j7ys.png)\n\n\n## Semaphore\n\n![](image-kke5mb82.png)\n\nlike a lock but multiple are available. Like a lecture hall instead of the bathroom.\nWe have 90 or so resources. The naming is a little bit different.\n\nacquire = P\nrelease = V\n\nNot different implementations, different uses.\n![](image-kke5ry5e.png)\n\nA barrier semaphore can be used to implement pthreads.join.\n\nThis is kind of like `shared_ptr` in C++.\n\n![](image-kke5tujk.png)\nA binary semaphore behaves like a lock, but it's not equivalent. Anyone could release it. it doesn't keep track of _ownership_.\n\n","tags":[],"folderPathname":"/CS350","data":{},"createdAt":"2021-01-26T14:34:28.030Z","updatedAt":"2021-01-26T15:37:57.951Z","trashed":false,"_id":"note:8reV8Fdlr","_rev":"98-6a4e8bd7e6441627fddcd873105a7687"}