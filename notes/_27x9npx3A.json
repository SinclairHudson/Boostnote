{"_id":"note:_27x9npx3A","title":"Module 2: Data Structures and Data Management","content":"# Module 2: Data Structures and Data Management\n\n!!! hint Abstract Data Type (ADT)\nA description of information and a collection of operations on that information. Information is accessed only through the operations (no tampering).\n!!!\nExamples include stacks, queues.\n\n#### heap2\n### Priority Queue\n\n![1c4cb469.png](1c4cb469-kl2ssw7j.png)\n### Implemented as an unsorted array:\nInserting is $O(1) \\iff \\text{array is not full}$, while deleteMax is $O(n)$. We assume dynamic arrays, so it's always assumed to be $O(1)$. It's **amortized** $O(1)$.\n### Implemented as a sorted array:\ninsert: $O(n)$\ndeleteMax: $O(1)$\n\nWe can use Priority Queues for a sort.\n![abaa44cb.png](abaa44cb-kl2ssw7l.png)\n\nIf we implement with an unsorted array, we get selection sort, which is worst-case $O(n^2)$.\n\nIf we implement with a sorted array, we get insertion sort, which has a runtime of Worst-case $O(n^2)$.\n\n### Implemented as a Heap:\n![b118a8cc.png](b118a8cc-kl2ssw7k.png)\n\nRemember, the height of a non-empty tree is the length of the longest path from $root \\to node$. The height of an empty tree is $-1$.\n\n![654329fc.png](654329fc-kl2ssw7k.png)\n\nThis is a **Max oriented binary heap**. We could sort by min, and also relax the binary property.\n\n!!! note Lemma:\nThe height of a heap (or any binary tree) with n nodes is $\\Theta(\\log{n})$.\n!!!\n\n!!! danger Storing Heaps\nHeaps should NOT be stored as binary trees! It's unintuitive, but the values should be in an array, and they should be indexed level by level.\n![37e96808.png](37e96808-kl2ssw7j.png)\n!!!\n![3d85ac84.png](3d85ac84-kl2ssw7k.png)\n\n### heap4\n### Operations in heaps:\n\nInsert:\n\n![22369a1c.png](22369a1c-kl2ssw7j.png)\n\nInsert is $O(\\log n)$.\n\n![c59d8b26.png](c59d8b26-kl2ssw7l.png)\n\nNow, if we make a priority queue using heaps, we get that insert and deleteMax is $O(\\log n)$.\n\n![d36ef900.png](d36ef900-kl2ssw7l.png)\n\n#### heap5\n\nWhen implementing priority queues using binary heaps, $PQSort$ now takes $O(n \\log n)$ time, which is better than the $n^2$ implementations with the arrays. But we can do a little bit better:\n\n### Heapify:\n\n![7267519d.png](7267519d-kl2ssw7k.png)\n\nThis alg uses more fix-downs instead of fix-ups. Heapify can be done in-place, which means constant extra memory!\n\n#### heap6\n\nProof that heapify is actually $\\Theta(n)$\n\n![8772a4c5.png](8772a4c5-kl2ssw7k.png)\n\nHeapsort iteration example.\n\n#### heap7\n\n![7fe247f0.png](7fe247f0-kl2ssw7k.png)\n\nLooking at selection problem solutions:\n\n![04ebd4db.png](04ebd4db-kl2ssw7j.png)\n\n","tags":[],"folderPathname":"/imported/CS240","data":{},"createdAt":"2020-05-25T00:40:42.464Z","updatedAt":"2020-06-01T21:59:26.189Z","trashed":false,"_rev":"BZK0eBr_93"}