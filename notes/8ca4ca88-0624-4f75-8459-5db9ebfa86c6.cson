createdAt: "2019-10-29T15:16:58.477Z"
updatedAt: "2019-10-31T15:04:17.808Z"
type: "MARKDOWN_NOTE"
folder: "13f1477d1dab07e879ca"
title: "Problem 22: I want to know what kind of book I have."
tags: []
content: '''
  ## Problem 22: I want to know what kind of book I have.
  
  For simplicity, assume we have the old hierarchy of Book -> Text, Book -> Comic
  
  The C++ casting operators:
  1) `static_cast`
  2) `reinterpret_cast`
  3) `const_cast`
  4) `dynamic_cast`
  
  In C:
  ```c
  (type) expr;
  
  int *p;
  int q = (int) p;
  ```
  
  This forces `expr` to be treated as type `type`.
  This is so unsafe, you can make very few guarantees. 
  
  
  ### `static_cast`
  The good one. For conversions with well-defined semantics.
  
  ```cpp
  void f(int a);
  void f(double b);
  int x;
  f(static_cast<double>(x));
  ```
  I know what it means when I convert a double to an int and vice versa. It's pretty safe.
  You can also convert a superclass pointer to a subclass pointer.
  
  ```cpp
  Book *b = new Text{...};
  Text *t = static_cast<Text *>(b); t->getTopic(); //you have to KNOW this will work
  ```
  
  If this doesn't work, we have undefined behaviour. The compiler has faith in you.
  
  ### `reinterpret_cast`
  For casts without well-defined semantics.
  Unsafe, implementation dependent.
  ```cpp
  Book *b = new Book{...};
  int *p = reinterpret_cast<int *>(b); //suuper sketchy lmao
  ```
  You put your faith in the compiler with this one.
  
  ### `const_cast`
  For adding/removing const. It's the only C++ cast that can "cast away" const.
  A const cast cannot change the reality of the read-only memory where a constant is stored.
  ```cpp
  void g(Book &b);
  void f(const Book &b){
    ...
    g(b) // g doesn't make the promise that it won't change b, so it's not allowed. 
    //but let's say we know that g doesn't modify b.
    g(const_cast<Book&>(b));
    ...
  }
  ```
  
  ### `dynamic_cast`
  
  ```cpp
  Book *b= ~~~~~~~~~~~~~~~~~~;
  
  Text *t = dynamic_cast<Text *>(b);
  ```
  What if we don't know whether b points to a Text?
  `static_cast` is not safe.
  If `*b` is a Text or a sublass of Text, cast succeeds, t points to the object. If not, t = nullptr.
  
  ```cpp
  if(t){...t->getTopic()...}
  else ... //not a text
  ```
  
  Dynamic reference casting:
  ```cpp
  Book *pb=~~~~~~~~~~~~~~~~~~~~~~~~~;
  Text &t = dynamic_cast<Text&>(*pb);
  ```
  If \\*pb is a Text - OK
  else, throws std::bad_cast
  
  !!! note Dynamic Casting
  Dynamic casting works by accessing an object's **Runtime Type Information (RTTI)** - this is stored in the **vtable** for the class. You can only use `dynamic_cast` on objects with at least one virtual method.
  !!!
  
  Dynamic reference casting offers a possible solution to the polymorphic assignment problem.
  ```cpp
  Text &Text::operator=(const Book &other){ //virtual
    Text &textOther = dynamic_cast<Text &>(other); //throws if other is not a text.
    if(this == &other) return *this;
    Book::operator=(other);
    topic = textOther.topic;
    return *this;
  }
  ```
'''
linesHighlighted: []
isStarred: false
isTrashed: false
