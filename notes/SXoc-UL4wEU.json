{"_id":"note:SXoc-UL4wEU","title":"Problem 11: Better Initialization","content":"## Problem 11: Better Initialization\n\nLong sequence of `push_back`s are clunky:\n\nArrays: `int a[] = {1,2,3,4,5};` :)\nVector: `vector v; v.push_back(1); v.push_back(2); ...` :(\n\nLet's fix that.\n```cpp\ntemplate <typename T> class vector{\n  ...\n  public:\n  vector(); ...\n  vector(size_t n, T i = T{}):n{n}, cap{n == 0?1:n}, theVector{new T [cap]}{\n      for(size_t j=0; j<n;++j) theVector[j]=i;\n    }\n}\n```\nNow we can do:\n```cpp\nvector <int> v; //empty\nvector <int> v{5}; // 0 0 0 0 0\n```\n!!! note T{}\nThe default constructor means 0 if T is a built-in type\n!!!\n\n```cpp\nvector<int> v{3,5}; // 5 5 5 - conversion\n```\nThis is good, but can we get the _true_ array style initialization?\nYes. Here's a lesson in trickery. :)\n\n```cpp\n#include <initializer_list>\ntemplate <typename T> class vector{\n  ...\n  public:\n    vector():...\n    vector(size_t, T i = T{}): ...\n    vector(std::initializer_list<T> init):n{init.size()},cap{n == 0?1:n}, theVector{new T[cap]}{\n      size_t i = 0;\n      for(auto t:init) theVector[i++] = t;\n    }\n}\n```\nSo, what this allows us to do now, is this:\n```cpp\nvector<int> v{1,2,3,4,5,6}; // 1 2 3 4 5 6\nvector<int> r; //empty\nvector<int> v{5}; // uhhhh (5)\nvector<int> v{3,5}; // what do these make? (3, 5)\n//so the other ctor, the newer one, is being called.\n```\nPrecedence goes:\n1) default constructors\n2) initializer_list constructors\n3) other constructors\n\nSo to get the other constructor to run, we need to use round bracket initialization.\n```cpp\nvector <int> v(5); // 0 0 0 0 0\nvector <int> v(3,5); // 5 5 5\n```\n\n!!! note Cost\nItems in an init list are stored in contiguous memory (begin/eng return ptrs). So we're basically using one array to build another, which means for a moment you have 2 copies of the array in memory. But you can't just use initializer_list as the data structure; they're meant to be immutable.\n* Do not try to modify their contents\n* Do not use them as standalone data structures.\n!!!\n\nBy using an `initializer_list` is actually usually more efficient. Since we double the size whenever we reach that cap on a `push_back`, there's a lot of deallocation or reallocation when we use `initializer_list`. In general, if you know how large your vector will be, you can save reallocation cost by requesting the memory up front.\n\n```cpp\ntemplate<typename T> class vector{\n  ...\n  public:\n    ...\n    void reserve(size_t newCap){\n      if (cap<newCap){\n        T *newVec = new T[newCap];\n        for(size_t i = 0; i<n;++i){\n          new Vec[i]=theVector[i];\n        }\n        delete [] theVector;\n        theVector = newVec;\n        cap = newCap;\n      }\n    }\n    ...\n}\n```\n`reserve` just saves us a bunch of reallocations. We can ask for memory up front now.\n```cpp\nvector<int>v;\nv.reserve(100);\nv.push_back(~~~); // can do 100 pushbacks without reallocating things.\n```","tags":[],"folderPathname":"/imported/CS246E","data":{},"createdAt":"2019-10-03T14:05:18.213Z","updatedAt":"2019-12-05T01:51:20.517Z","trashed":true,"_rev":"BuoOOhpSbPX"}