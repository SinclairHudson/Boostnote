{"_id":"note:G2jzaTii3ry","title":"Problem 14: Memory management is hard!","content":"## Problem 14: Memory management is hard!\n\nNo it isn't.\n- Vectors can do everything arrays can do\n- they grow as needed in $O(1)$ (amortized).\n- Clean up autimatically when they go out of scope.\n- Tuned to minimize copying.\n\nUse vector, and you'll never have to manage arrays again. \n\nC++ has enough abstraction abilities to make programming easier than in C.\n\nBut what about single objects? Those aren't arrays.\n```cpp\nvoid f(){\n  Posn *p = new Posn{1,2};\n  ...\n  delete p; //must deallocate the Posn. not that bad. \n}\n```\n\nFirst ask:\nDo you need to use the heap? Could you have used the stack instead?\n\n```cpp\nvoid f(){\n  Posn p{1,2};\n  ... //no cleanup.\n}\n```\nSometimes you need the heap. Calling delete isn't so bad. \nNow, consider:\n\n```cpp\nclass BadNews{};\nvoid f(){\n  Posn *p = new Posn{1,2};\n  if(some condition) throw BadNews{};\n  delete p; \n} // p is leaked if f throws\n```\n\nRaising + handling an exception should not corrupt the program. Let's fix that. We desire **exception safety**.\n\nLeaks are a corruption of the program's memory. They will eventually degrade performance and crash the program. If we can't recover properly, then we might as well crash.\n\n**What constitutes exception safety?**\n\n3 levels:\n1) Basic guarantee - once an exception has been handled, the program is in some valid state. No leaked memory, no corrupted data structures, any invariants are still true.\n2) Strong guarantee - if an expression propagates out of a function `f`, then the state of the program will be as if `f` had not been called. `f` either succeeds completely or not at all.\n3) No-Throw guarantee - `f` offers the no-throw guarantee if it never emits an exception, and **always** accomplishes its purpose.\n\nWe will revisit this.\nBut back to `f`.\n```cpp\nclass BadNews{};\nvoid f(){\n  Posn *p = new Posn{1,2};\n  if(some condition){\n    delete p; //duplicated effort\n    throw BadNews{};\n  } \n  delete p; //duplicated effort\n} //looks like memory management isn't that easy after all...\n```\nWe only want to say the same thing once.\nWe want to guarantee that `delete p;` happens no mater what.\nIn other languages, you can use something like `finally`. \n![pather.jpg](https://i.kym-cdn.com/entries/icons/original/000/026/366/pather.jpg)\nIn C++, we do something different. C++ only guarantees that destructors for stack-allocated objects will be called when they go out of scope.\n\nLet's create a class with a destructor that deletes the pointer. \n\n```cpp\ntemplate<typename T> class unique_ptr{\n  T *p;\n  public:\n    unique_ptr(T *p):p{p}{}\n    ~unique_ptr(){delete p;}\n    T *get() const {return p;}\n    T *release(){\n      T *q=p;\n      p = nullptr;\n      return q;\n    }\n};\n\n//now f\nvoid f(){\n  unique_ptr<Posn>p{new Posn{1,2}};\n  if(some condition) throw BadNews{};\n}\n```\n\nAnd that's it - less memory management effort than we started with!\n\nUsing `unique_ptr` - we can use get to fetch the pointer.\nBut we can do one better: make the `unique_ptr` act like a pointer by giving it pointer operations.\n```cpp\ntemplate<typename T> class unique_ptr{\n  T *p;\n  public:\n  ...\n  T &operator *() const {return *p}; //return the internal pointer dereferenced.\n  T *operator->() const { //return the thing you want the compiler to apply the arrow to.\n    return p; //THIS IS WEIRD! but so is the arrow operator so meh.\n  }\n  operator bool() const { return p; }\n  void reset(T *p1){ delete p; p = p1;}\n  void swap(unique_ptr &other){std::swap(p, other.p);}\n};\n\nvoid f(){\n  unique_ptr<Posn> p {new Posn{1,2}};\n  cout << p->x << ' ' << p->y <<endl;\n}\n```\nBut Consider:\n\n```cpp\nunique_ptr<Posn> p {new Posn{1,2}};\nunique_ptr<Posn> q = p; //OOF\n```\nEssentially, we have two pointers to the same object, and they can't both delete it. That would be undefined behaviour.\nSo what do we do?\n\nCopying `unique_ptrs` is simply not allowed. But it would be ok to move them.\nSo here's the fix:\n```cpp\ntemplate<typename T> class unique_ptr{\n  T *p;\n  public:\n  ...\n  unique_ptr(const unique_ptr &other) = delete; //this is how streams are uncopyable\n  unique_ptr &operator=(const unique_ptr &other) = delete;\n  unique_ptr (unique_ptr &&other):p{other.p}{other.p=nullptr;}\n  unique_ptr &operator=(unique_ptr &&other){\n    swap(other);\n    return *this;\n  }\n  ...\n};\n```\n!!! note Copying of streams\nThis is how copying streams is prevented.\n!!!\n\nBut there's a small exn safety issue. Consider:\n```cpp\nclass c {...};\nvoid f(unique_ptr<c>x, int){...}\nint g(){...}\n\nf(unique_ptr<c>{new C}, g());\n```\n!!! danger Argument Evaluation\nC++ does not enforce an order of argument evaluation.\n!!!\nIt could be that \n1) new C\n2) g()\n3) unique_ptr<c>{(1)}\n\nand what if g throws? Yeets? 1) is leaked.\nSo we need to make 1 and 3 inseparable, so that nothing whack occurs between them.\n\nThe Solution: a helper function\n\n```cpp\ntemplate <typename T, typename... Args>\nunique_ptr<T> make_unique(Args&&... args){\n  return unique_ptr<T>{new T(std::forward<Args>(args)...)};\n}\n```\n\nExample becomes\n\n```cpp\nf(make_unique<c>(), g()); //checkmate bitch\n//make_unique either runs in full or it doesn't.\n```\nNo leak if g throws\n\n![maxresdefault.jpg](https://i.ytimg.com/vi/m5gVQvYNUdI/maxresdefault.jpg)\n\n`unique_ptr` is an example of the C++ idiom called **Resource Acquisition Is Initialization**. (RAII)\n\n!!! note Resource Acquisition Is Initialization (RAII)\nAny resource that must be properly released (memory, file handle, etc.) should be wrapped in a stack-allocated object who's destructor frees it.\nThis is a very important concept in this course\n!!!\n\nExamples of RAII\n* unique_ptr\n* ifstream/ofstream\n\nAcquire the resource when the object is initialized, and released when the object's destructor runs.","tags":[],"folderPathname":"/imported/CS246E","data":{},"createdAt":"2019-10-08T14:59:58.661Z","updatedAt":"2019-12-05T02:23:09.190Z","trashed":true,"_rev":"cUeHYhb5qBI"}