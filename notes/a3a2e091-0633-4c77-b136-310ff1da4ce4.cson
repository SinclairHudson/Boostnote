createdAt: "2019-10-22T14:33:40.744Z"
updatedAt: "2019-12-11T20:12:23.901Z"
type: "MARKDOWN_NOTE"
folder: "13f1477d1dab07e879ca"
title: "Problem 16: Insert/remove in the middle"
tags: []
content: '''
  ## Problem 16: Insert/remove in the middle
  
  A method like `vector<T>::insert(size_t i, const T &x)` is easy to write.
  But the same method for `list<T>` would be slow (linear traversal)
  Using iterators can be fast for both.
  ```cpp
  template<typename T> class vector{
    ...
    public:
    iterator insert(iterator posn, const T &x){
      ptrdiff_t offset = posn - begin();
      increaseCap();
      iterator newPosn = begin()+offset;
      new (end()) T(std::move_if_noexcept (*(end()-1)));
      ++ub.n;
      for(iterator it= end() - 1; it !=newPosn; --it){
        *it = std::move_if_noexcept(*(it-1));
      }
      *newPosn = x;
      return newPosn;
    }
  }
  ```
  Is it exception safe?
  Assuming T's copy/move ctor copy/move assign are exception safe (at least basic guarantee), insert also offers the basic guarantee.
  You may get a partially-shuffled vector, but it will be a valid vector.
  !!! note Note:
  If you have other iterators pointing at the vector, the iterators will point at the same spot, but at a different item.
  !!!
  
  !!! hint Convention:
  after a call to insert or erase, all iterators pointing after the point of insertion or erasure are considered invalid and should not be used. 
  !!!
  
  Similarly, if a reallocation happens, all iterators that you had are now invalid.
  
  But now, there's a problem with `push_back`.
  If placement new throws, the vector is the same, but iterators were invalidated!
  
  To fix: don't throw away the old array until you have placed the item.
  - place the last item first (placement new)
  - `uninitialized_copy_or_move` the old array
  - catch any exceptions - destroy the last item +rethrow
  - if all succeeds, swap arrays, destroy_elements on the old one.
  
  ---
  We can use iterators to modify certain parts of a list or a vector.
  What if I want to transform a list to a vector, or vice versa?
  Make the type variables stand for the iterators, not the container elements.
  
  ```cpp
  template <typename InIter, typename OutIter, typename Fn>
    void transform (InIter start, InIter finish, OutIter target, Fn f){
      while (start != finish){
        *target = f(*start);
        ++start; //works over vector iterators, list iterators, or any other iterators.
        ++target;
      }
    }
  ```
  InIter/OutIter can be any types that support ++, *, !=.
  
  Fn can be any type that supports function application.
  Eg.
  ```cpp
  class Plus{ //this is what we call a function object.
    int n;
    public;
      Plus(int n):n{n}{}
      int operator()(int m){return n+m;}
  }
  ```
  
  !!! note Lambdas
  `[](int n){return n+1;}` is lambda syntax for C++. But it's not really a lambda.
  `[capture list](parameter list) mutable? noexcept? { body }`
  Lambdas are just classes that have a round bracket operator.
  Capture list - provides access to selected vars in the enclosing scope.
  if mutable, then things in the capture list can be mutated.
  !!!
  Lambdas translate to
  ```cpp
  class ~~~~~~~~~{ //anonymous class
    T1 a;
    T2 &b;
    public:
      ~~~~~~~~~(T1 a, T2 &b):a{a},b{b}{}
      auto operator()(int x) const {body;}
  };
  ~~~~~{a,b}.operator()(......);
  ```
  
  If the lambda is declared mutable, then operator () is not const.
  
  ### Midterm coverage ends.
'''
linesHighlighted: []
isStarred: false
isTrashed: false
