{"_id":"note:CIMR4H_xzQk","title":"Problem 19: I'm leaking!","content":"## Problem 19: I'm leaking!\n\nConsider:\n```cpp\nclass X{\n  int *a;\n  public:\n    X(int n):a{new int{[n]}}{}\n    ~X(){delete []a;}\n}\n\nclass Y: public X{\n  int *b;\n  public:\n    Y(int n, int m):X{n}, b{new int[m]}{}\n    ~Y(){delete [] b;}\n}\n```\nOk. Y's destructor will call X's destructor. (Step 3);\n\n```cpp\nX *px = new Y{3,4}; //normal. pointing a parent pointer at a child object.\ndelete px;\n```\nThe above code leaks. but why? X's destructor is running, not Y's. So the extra memory that Y takes up will be leaked. \n\nWe need to make the destructor **virtual**.\n```cpp\nclass X{\n  int *a;\n  public:\n    X(int n):a{new int{[n]}}{}\n    virtual ~X(){delete []a;} //fixes\n}\n```\n\nAlways make the destructor virtual in classes that are meant to be superclasses. Even if the destructor does nothing. You never know what the subclass might do. Si you need to make sure its destructor gets called. If a class is not meant to be a superclass, no need to incur the cost of virtual methods needlessly. leave the destructor non-virtual.\n\nDeclare the class **final** if you want to prevent subclassing.\n```cpp\nclass X final{ //cannot be subclassed\n  int *a;\n  public:\n    X(int n):a{new int{[n]}}{}\n    virtual ~X(){delete []a;} //fixes\n}\n```\n---\n","tags":[],"folderPathname":"/imported/CS246E","data":{},"createdAt":"2019-10-29T14:00:35.672Z","updatedAt":"2019-10-29T15:43:00.738Z","trashed":true,"_rev":"9qnn6CERqJL"}