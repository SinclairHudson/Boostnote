{"title":"L2: Threads","content":"# Lecture 2: \n\nDo work on linux server.\n\n## GM-NAA I/O\n1956, worked on the IBM 704  \nDeveloped by GM and NAA  \nHad a **resident monitor** (programs were called jobs) and a **batch processor**  \nAutomatically loads the next job upon completion of another (a queue)  \nthis is an Operating System.  \nIt also offered a library for routines for I/O devices.\n\n## Threads\n\nWhat is a thread? What's **co-currency**?\n\nIn the past, we only run one job at a time. There was just one sequence of instructions. Just one game, one program, etc.\n\nThis is kind of a waste of resources.   \nA disk drive in the old days took a long time to read and write.   \nActually, 10 minutes. And while the disk drive is getting its stuff sorted, the **CPU is idle**. \nAnd compute time is in high demand.  \n\nMaybe, while the disk is doing its thing, another operation can be run. \nThis is called **multi-programming**.\n\nIt's not really co-currency, because it just improves CPU utilization time.\n\n## Threads and Concurrency.\n\nWhat is a thread?\n\nIt's just a **sequence of instructions**. Could be a C program.\n\nThreads provide a way for programmers to express **concurrency**.\n\nThis allows us to have:\n* Better resource utilization\n* Parallelism - (if we can execute more commands at once).\n* Responsiveness - Dedicate threads to UI.\n* Priority - give important threads more time on the CPU.\n* Modularization - organization of execution tasks/responsiblities.\n\n:::danger Blocking\n\nThreads may **block**, ceasing execution for a period of time, until some condition has been met. It's stopped, the CPU is idle. So we can execute a different thread while we're waiting! Increases CPU uptime. CPU time is money. STONKS\n:::\n\nThreads are very important in all applications.\n\n### Example\nA thread can create new threads using `thread_fork`.  \nThe original thread and the new thread created proceed cocurrently.\nThreads have names, for debugging.  \nWhen we fork a thread, we pass a function; the function we want the thread to execute.\nThe threads take turns on the CPU, and this is **non-deterministic**.  \nWhenever there is a block (IE displaying something on the screen).  \nBut it's not always blocking; sometimes we **intentionally switch between them really fast**, to make it seem like all threads are making progress at the same time.  \n\n![](image-kjwzn4ho.png)\n\n`thread_exit` kills immediately.\n`thread_yeild` voluntarily block the thread, it will **try** to give up the CPU. There's a chance that the thread that called yeild will take the CPU back again, if there are no other candidates that want the CPU. \n\n![](image-kjwzqoip.png)\n\nCUDA :weary:. GPUs are far more parallelizable. 1000s of cores, but also they must run the same command. So good for AI :smirk:, but not for OSs.\n\n`fbomb` a \"fork bomb\". It's a recursive function, where every call creates new threads and new threads and new threads. Exponential growth of threads. You'll run out of resources very fast.\n\n`# pragma omp parallel for` is syntax for OpenMP which parallelizes the loops.\n\nThe maximum number of threads depends on:\n* Implementation of the OS (programmed limit so there's no crash)\n* The hardware you have (memory is probably the limiting factor)\n\n`time` command in linux:\n* `real` - real time\n* `user` - how much time the user took TODO\n* `sys` - how much time the system took during the task to due other things.\n\nyou can use this command to look at how multi-threaded applications perform.\n\n### How is multithreading happening?\n\n![](image-kjx0abgv.png)\n\n![](image-kjx0bfph.png)\nThis is a good compiler optimization.\n\n![](image-kjx0h1ju.png)\n\nIt's better if we use **1 thread for each stack**. We _could_ use 1 stack, but it would be a nightmare.  \nWhen we stash a thread, we store all of its register values in the **corresponding stack**.\n\n:::question But won't the stacks overlap?\nStacks actually have a default size, so they don't overlap. 1-2MB is the industry standard, generally. in OS161, it's much lower. KB, not MB.\n:::\n\nBecause of this, the heap is better for **large objects**.\n\n### What are our options for Concurrency?\n![](image-kjx0q2g0.png)\n\n:::danger GDB\n\nYOU HAVE TO USE GDB. Print statements don't work; they change the thread cycle.\n\n:::","tags":[],"folderPathname":"/CS350","data":{},"createdAt":"2021-01-12T16:10:47.773Z","updatedAt":"2021-01-21T14:49:05.947Z","trashed":false,"_id":"note:k4Kd94YUI","_rev":"140-e61f3631957d5164308cd2d2cdbc6eca"}