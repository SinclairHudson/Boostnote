{"_id":"note:n5uHWAWlzt9","title":"Week 09: More MultiCyle","content":"# Week 09: More MultiCyle\n\nRemember, forwarding.\n\n![0376b043.png](0376b043-kl2t952x.png)\n\n!!! danger Load Word Hazard\nWhen LDUR is followed immediately by an instruction that uses LDURs destination Register. We use a single NOP to fix this hazard.\n!!!\n\n---\n\nWhat about, instead of NOPs, we just rearrange the code...? Restructure the code. That's called **Code Rearrangement**.\n\nThere are obvious guidelines with code rearrangment. Don't swap lines with data dependencies,\nand don't move inside or outside of loops.\n\nWhen computing execution time, we have to factor in pipeline startup time. This is 4 clock cycles, because we begin producing completed instructions after 4 clock cycles. After that, we produce one completed instruction per clock cycle.\n\n\nWhen you need to add a NOP, you can actually do that in the hardware, and not the compiler.\nWe can add a **Hazard Detection Unit** to the data path, which takes the RN and Rm from the IF/ID intermediate register. It also gets ID/EX Memread, to check if there's a hazard. Implementation is fairly simple:\n1. Zero out Control Bits - Converts instruction into NOP\n2. But also block  IF/ID and PC from updating, so it doesn't skip anything.\n\nEffectively, we're letting the following instruction move forward, but a NOP version. And you keep the ID and IF and PC from updating so they're still in position.\n\n![591a18e5.png](591a18e5-kl2t952x.png)\n![d5801669.png](d5801669-kl2t952x.png)\nIt's a stall, which is a hardware level NOP.\n\n---\n\n### Pipelining Control Hazards\n\nControl Hazards involve branching.\n!!! caution In this section, we're assuming branch in the mem stage.\n![4c4b0dad.png](4c4b0dad-kl2t952x.png)\n!!!\nThe issue is that we only know if `CBZ` or `CBNZ` is going to be branching at the MEM stage. At that point, we've already loaded the next 3 instructions, which we don't want to execute. These instructions are called \"errant\" intructions.\n\nWe have to _flush_ the pipeline. We need to terminate them. Convert them into NOPs.\n\nTo cancel an operation, you just zero out the control bits. However, the instruction in the IF stage doesn't have control bits yet! In that case, we simply convert it into an R-format, and then put set the destination register to `X31` (the one that's always 0). So modify the instruction bits.\n\nOf course, if you don't take the branch, there's no problem.\n\nOk, so we waste 3cc per branch. This is a bit of an issue. How do we fix it?\nWell, we can actually pull the Branch instructions into the `ID` stage.\n\n![f418f959.png](f418f959-kl2t952y.png)\n\nNow, if we branch, we only have to flush 1 instruction, 1cc wasted. Way better than 3.\nWe also add IF.Flush, which is a control bit that is in charge of flushing after the IF stage. It's logic is unclear, but it sets the instruction to R format and then zeroes the write register.\n\n---\n\n### Code analysis\n\nBasically, if you do the cc analysis for loops, they're really inefficient if you have to flush and if you have to load stall. If you end your loop with a `CBNZ`, and you're branching in the MEM stage, then the 3 instructions after the end of the loop will still be fetched and flushed, on all but the last iteration. This adds $3n$cc to your program, where $n$ is the number of iterations.\n\nHowever, if you have branch in the `ID` stage, then you only have to add one cc per iteration. That's just $n$.\n\nIf you have no flushing, you'll actually have to but NOPs after the loop to avoid errant instructions from actually being executed.\n\nBut there's a problem: It's with forwarding. The issue is that with branch in the ID stage, we don't have time to fix data hazards above the `CBZ` stage. That gets fixed for the `EX` stage. So `CBZ` won't be using the right register value in the `ID` stage.\n\nThis is called a \n!!! caution Branch Data Hazard\n\n```\nSUBI X1, X1, #1\nCBNZ X1, #-4\n```\nWhat's the solution? A hardware level **stall**.\n\nThis is called **Branch Data Stalling**.\nIt has a cost of 1cc, in the loop usually.\n!!!\n\n!!! danger Double Counting\nBe careful not to double-count the instruction after the CBNZ, especially at the end of a loop. It's already fetched when the loop is executed, just not executed (until now). So you count it as part of the loop, and not after.\n!!!\n\n---\n\n## Branch Prediction\n\nCan we avoid flushing?\n\nThe thing we've been doing so far is **predict branch not taken**. Pretty self-explanatory. We always predict that the next instruction (one we load) is just $PC=PC+4$.\n\nNext is **predict branch taken**. Instead of automatically updating $PC=PC+4$, automatically update to the branch target address. You need to store the BTA in the IF stage to do this (and you also need to store the address of the CBZ instruction itself). If we don't take the branch, we'll have to flush.\n\nIn actual application, Predict Taken is hard.\n\nThe advantage for Predict Taken is that you're probably branching more than you're not. So you get more corrects than incorrects, so less flushing.\n\nThere's an extension to this **one bit prediction**, which is easier to implement properly. Essentially, we're storing what we did last time in a table, so that next time the cycle can predict that we'll do that again. The table can hold multiple entries for multiple CBZs in a program.\n\n![df1e6b64.png](df1e6b64-kl2t952y.png)\n\n---\n\nFinally, we have **two-bit prediction**. Similar to one-bit, but now with a confidence factor. The 2 bits denote the state in the FSM.\n00 is strong not taken\n01 is not taken\n10 is taken\n11 is strong taken\n\n![c7e64c7c.png](c7e64c7c-kl2t952x.png)\n\nThis one is obviously more robust to one-off wrong predictions.\n\nIt's also nice for nested loops, because you exit the interior, and then when you come across it again you don't assume you're exiting first time.\n\n\n### Performance of Pipelined Design\nThe main metric here is **Clock cycles per instruction**.\n\nWe assume the gcc distribution of instructions:\n22% loads\n11% stores\n49% R-format\n16% branches\n2% jumps\n\nWe also assume half of all `LDUR` generate a load-use hazard.\nWe assume one quarter of branches are mispredicted.\nSo you can calculate the average CPI, by calculating the average per instruction type and then multiplying by the proportion of the code that is that instruction type.","tags":[],"folderPathname":"/CS251","data":{},"createdAt":"2020-07-13T00:00:50.116Z","updatedAt":"2020-08-14T18:01:29.935Z","trashed":false,"_rev":"sfy8OhO9Jqw"}