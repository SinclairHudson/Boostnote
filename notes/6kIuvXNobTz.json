{"_id":"note:6kIuvXNobTz","title":"Week 04","content":"# Week 04\nThis week, we'll be using D-FlipFlops to implement registers. Each D-FlipFlop stores one bit of data.\n### Register files\nPutting registers together and adding baking creates a register file.\nRegister files are used as memory.\n\n![c69a88a5.png](c69a88a5-kl2t950k.png)\n\nA **Register** is an array of Flip Flops (32 for word registers).\nA **Register File** is a way to organize registers.\n\n![65c53346.png](65c53346-kl2t950k.png)\n\n#### Writing\nWe need the address, we need the write bit to be true, and we need the data.\n\n![54f0364b.png](54f0364b-kl2t950k.png)\n\nThe above diagram makes a lot of sense. Writing only occurs when the write bit is _true_, and the register number comes from the decoder. It does what it should, it's pretty straightforward.\n\nRemember, for this course, we assume 64-bit ARM. this means that the registers have 64 bits. The number of registers is actually unspecified. The write data has the same number of bits as the registers, obviously.\n\n#### Reading\n\nWhy 2 reads? Well, we almost always read one at a time.\n```\nADD X1, X2, X3 ; like here\n```\n![84d751dc.png](84d751dc-kl2t950k.png)\n\nThe above diagram is pretty simple as well. The muxes just forward the requested registers based on the register number. We need $n$ register select bits if we have $2^n$ registers.\n\n---\n\nSo now take a look at the big picture again. The register file is just the reads and writes combined. It looks complicated, but the circuitry is actually pretty simple, and how you would design it if you tried from scratch.\n\n### Finite State Machine\n\nYou already know. It's really like a finite-state-automaton, as in CS241. A state machine is any device that stores the status of something at a given time and can operate on input to change the status.\n\n![33bd56d5.png](33bd56d5-kl2t950j.png)\n\nRemember to keep the looped transitions in there! \n\n**Moore machines** are mainly what we use in this course. it means that the output only depends on the state.\n\n![7dc287c8.png](7dc287c8-kl2t950k.png)\n\nWe can use these diagrams, but we can also use what's called a **next-state table**.\n\nIt has current state, input, and then next-state.\n\n![8cbb006b.png](:storage/38fbd035-7f63-4b95-9e25-edf8d5084d03/8cbb006b.png)\n\nWe can label all the inputs and states in a binary fashion, and then we can make a boolean expression for each of the \"bits\" of the next state encoding. Like so:\n\n![40e317ea.png](40e317ea-kl2t950j.png)\n\nWe can also make what's called the **output table**, where we have the state bits on one side and the corresponding outputs on the other side:\n\n![7de4fbe0.png](7de4fbe0-kl2t950k.png)\n\nAs you can imagine, we can derive boolean expressions for all of the outputs too, in terms of the state bits.\n\nWe can use all of these tools to implement a circuit for the state machine:\n\n![a3545118.png](:storage/38fbd035-7f63-4b95-9e25-edf8d5084d03/a3545118.png)\n\n","tags":[],"folderPathname":"/CS251","data":{},"createdAt":"2020-06-06T16:39:58.589Z","updatedAt":"2020-08-14T17:46:12.547Z","trashed":false,"_rev":"we0CuXqknXn"}