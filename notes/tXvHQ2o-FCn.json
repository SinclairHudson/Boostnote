{"_id":"note:tXvHQ2o-FCn","title":"Problem 25: I want an even faster vector","content":"## Problem 25: I want an even faster vector\n![96d.jpg](https://i.kym-cdn.com/photos/images/newsfeed/001/473/129/96d.jpg)\n\nIn the good old days of C, you could copy an array very quickly. Even an array of structs.\nThe function was **memcpy** (similar to strcpy), but for arbitrary memory, so not just strings.\n\n**memcpy** was probably written in assembly, and was as fast as the machine could possibly be. \n\n---\n\nBut C++ is more complicated. Copies invoke copy Constructors, which are costly function calls.\n\nIf we're talking about simple data, we could still technically use `memcpy`.\n\n!!! hint POD (plain old data)\n\n* has a trivial default constructor ( = default)\n* if it's trivially copyable. (copy/move/destructors have defailt implementations)\n* is **standard layout** (it looks like C)\n  * no virtual methods, or bases.\n  * all members have the same visibility.\n  * no reference members\n  * no fields in both base class and subclass, or in multiple bas classes.\n!!!\n\nFor POD types, the semantics are compatible with C, and `memcpy` is safe to use.\n\nHow can we use it? Only safe if T is a POD type.\n\n```cpp\ntemplate <typename T> class vector{\n  T *theVecotr;\n  size_t n, cap;\n  public:\n    ~~~~\n    vector(const vector &other): theVector{static_cast<T*>(operator new (other.n*sizeof(T)))},\n    n{other.n}, cap{other.cap}{\n      if(std;;is_pod<T>::value){ //but this should be known at compile-time\n        memcpy(theVector, other, theVecotr, n*sizeof(T));\n      }\n      else{\n      ~~~~ //AS BEFORE\n      }\n    }\n}\n```\nSo here's the second option, involving no runtime cost:\n\n!!! danger Doesn't work\n```cpp\ntemplate <typename T> class vector{\n  ~~~~\n  public:\n    template <typename x = T> vector(enable_if<std::is_pod<x>::value, const vector<T>&>::type other):\n    theVector{~~~~~},n{~~~~~},cap{~~~~~~~}{\n      memecpy(theVector, other.theVector, n*sizeof(T));\n    }\n    template<typename x = T> vector(enable_if<!std::is_pod<x>::value, const vector<T>&>::type other):\n    theVector{~~~~~{,n{~~~~},cap{~~~~~}{\n      for(size_t i = 0; i < n; ++i){\n        new (theVector+i) T(other[i]);\n      }\n    }\n    ~~~~~~\n};\n```\n!!!\n\nHow does this work?\n```cpp\ntemplate<bool b, typename T> struct enable_if;\n\ntemplate<typename T> struct enable_if<true,T>{\n  using type = T;\n};\n```\n\nWith metaprogramming, what you don't say is as important as what you do say.\nIf b is true, enable_if defines a struct whose 'type' member typedef is T. So if stdLLis_pod<T>::value == true, then `enable_if<is_pod<T>::value, const T&> == const T&`\n\nIf b is false, the struct is declared, but not defined. So enable_if<b,T> won't compile.\n\nSo one of the two versions of the copy constructor (the one with the false condition) won't compile.\n\nSo then how is this a valid program?\n\n!!! note SFINAE\nSubstitution failure is not an error. The compiler eliminates that function as a valid option. If t is a type, and template<typename T>__f(__){____} is a template function, and substituting T=t results in an invalid function, the compiler does not signal an error. ALl it does is remove that function from consideration during overload resolution.\n!!!\n\nOn the other hand, if no version of the function is in scope to handle the call, that is an error.\nQ: Why is this wrong?\n\n```cpp\ntemplate <typename T> class vector{\n  ~~~\n  public:\n  vector(enable_if(is_pod<T>::value, const T&)::type other){~~~~~}\n  vector(enable_if(!is_pod<T>::value~~~~~~~~))\n};\n```\nThe copy constructors must be templated, because SFINAE applies to template functions, and those constructors would be ordinary functions. It depends on T, but T's value has already been set. SO make the constructor a template woth new arg X, which can be defaulted to T. But the above program does not work.  \n\nAnd it's because we're getting the compiler-supplied copy constructor, which is doing shallow copies. These tempaltes are not enough to suppress the auto-generated copy constructor. A non-templated match is always preferred to a non-templated one. \n\nYou're not allowed to disable the copy constructor and then define your own... but it's a good idea.\n\nSolution: overloading.\n```cpp\ntemplate <typename T> class vector{\n  ~~~~\n  struct dummy {};\n  public:\n    vector(const vector &other):vector{other,dummy{}}{}\n    template <typename x = T> vector(enable_if<std::is_pod<x>::value, const vector<T>&>::type other, dummy):\n    theVector{~~~~~},n{~~~~~},cap{~~~~~~~}{\n      memecpy(theVector, other.theVector, n*sizeof(T));\n    }\n    template<typename x = T> vector(enable_if<!std::is_pod<x>::value, const vector<T>&>::type other, dummy):\n    theVector{~~~~~{,n{~~~~},cap{~~~~~}{\n      for(size_t i = 0; i < n; ++i){\n        new (theVector+i) T(other[i]);\n      }\n    }\n    ~~~~~~\n};\n```\nWe get around this by using a dummy struct, so the parameters are different, but the default ends up calling one of our own constructors.\n\nThis is really clunky, so C++14 provides helper definitions.\n```cpp\ntemplate<typename T> constexpr bool is_pod_v = is_pod<T>::value\n\ntemplate <bool b, typename T> using enable_if)t = typename enable_if<b,T>::type\n```\nWHich enables:\n```cpp\ntemplate<typename T> class vector{\n  ~~~~~\n  public:\n    template<typename x = T> vector(enable_ift<is_pod_v<x>, const vector<T>&> other, dummy){ ~~~~~}\n    ~~~~\n};\n```\n\n### Generic Visitor Pattern:\n```cpp\n\ntemplate <typename ...> class visitor{\n  public:\n    void visit(){}\n    virtual ~Visitor(){}\n};\n\ntemplate<typename T, typename ... Ts> class Visitor<T,Ts ...>\npublic Visitor<Ts...>{\n    public:\n      using Visitor<Ts ...>::visit; //bring this method into scope\n      virtual void visit(T&x) = 0; //so this ends up bringing visit commands in for each Class you specify. They accumulate.\n};\n```\n\nusing BookVisitor = Visitor<Book, Text, Comic>;\n\n### Move/forward Implementation\nstd::move: first attempt\n```cpp\ntemplate <typename T> T && move (T&&x){\n  return static_cast<T&&>(x);\n}\n```\nDoesn't quite work - T && is a universal reference, not an rvalue ref.  So if x was an lvalue, T && will be an lvalue ref. We need to make sure the type is not an lvalue ref. If T is an lvalue ref, get rid of the ref.\n\nstd::move: correct version\n```cpp\ntemplate <typename T> inline typename std::remove_reference<T>:: type && move (T &&x){\nreturn static_cast< typename std::remove_reference<T>::type &&>(x); //turns T& / T&& into T\n}\n```\nstd:: forward - first attempt\n\ntemaplte <typename T> inline T&& forward (T &&x){\n  return static_cast<T&&>(x);\n}\nReasoning: if x is an lvalue, T&& is an lvalue ref. If x is an rvalue, T&& is an rvalue ref. But x is always an lvalue, so this reasoning is flawed. Forward is called on expressions that may \"point\" to rvalues, but are lvalues.\n\nIn order to work, forward must know what type was deduced for x. So forward<T>(x) would work, while forward(x) would not work.\n\nThis works:\n```cpp\ntemplate<typename T> inline comstexpr T&& forward(std::remove_reference<T> &x){\n    return static_cast<T&&>(x);\n  }\n```\n\nQ: can we save some typing:\n```cpp\ntemplate<typename T> auto move(~~~~)~~~~~\n```\nNo, not in that way. By-value auto throws away refs + outerconsts.\n```cpp\nint z;\nint &y = z;\nauto x = y; //x is int\nconst int &w = z;\nauto v = w; //v is int\n```\nauto uses the type a value would have in expressions if copied.\n\nWe need a type deduction rue that doesn't discard refs.\n\nenter `decltype(~~~~)`. This returns the type ~~~~ was declared to have.\n\n`decltype(var)` - returns the declared type of the var.\n\ndecltype(expr) - returns an lvalue or rvalue ref, depending on whether expr is an lvalue or rvalue.\n\n```cpp\nint z;\nint &y = z;\ndecltype(y) x = z; //x is an int&\nx = 4; //affects z\n\n//As opposed to\nauto x = z;\nx = 4 //does not affect z\n\n//as opposed to\ndecltype(z) s = z; //s is int\ns = 5; //does not affect z\n\n//as opposed to \ndecltype((z)) r =z; // r is int&\nr = 6; //affects z\n```\nTo use,\n```cpp\ndecltype(auto) //perform type deduction like auto, but use the decltype rules.\n```\nCorrect move:\n```cpp\ntemplate <typename T> decltype(auto) move(T &&x){\n  return static_cast<std::remove_reference_t<x>&&>(x);\n}\n```","tags":[],"folderPathname":"/imported/CS246E","data":{},"createdAt":"2019-11-20T18:00:28.056Z","updatedAt":"2019-11-26T15:10:27.282Z","trashed":true,"_rev":"GDIco-ktjlP"}