{"_id":"note:HDx5FGN573e","title":"Problem 09: Staying in Bounds","content":"## Problem 09: Staying in Bounds\n\n```cpp\nvector v;\nv.push_back(4);\nv.push_back(5);\nv[2]; //illegal OOF, undefined behaviour. arrayOutOfBoundsException\n```\nBut can we make it safer?\n\nAdding bounds checks to `operator[]` may be needlessly expensive.\nAlternatively, we could provide a second operator that has extra checks, and then the user could decide which one they want to use.\n\n```cpp\nclass range_error{};\nclass vector{\n  ...\n  public:\n    int &at(size_t i){\n      if(i<=n){\n        return a[i];\n      }\n      else{\n      //??? it doesn't \"fix\" the problem.\n      //we can't just return a flag int like -1\n      //returning something that's not an int isn't an option, type error\n      //crash the program intentionally? - can we do better?\n      //We need to raise an 'exception'\n        throw range_error{}; //construct an object and throw it.\n      }\n    }\n}\n```\nExceptions are like baseballs.\nClient options:\n1) Do nothing - will crash the program\n2) Catch it -\n```cpp\ntry{\n  vector v;\n  vector.push_back(1);\n  v.at(1);\n}                 //r is the thrown object, caught by reference.\ncatch(range_error &r){\n  //do something\n}\n```\n3) let your caller catch it.\n```cpp\nint f(){\n  vector v;\n  v.push_back(1);\n  v.at(1);\n}\nint g(){\n  try{\n    f();\n  }\n  catch(range_error &r){\n    //do something\n  } //control resumes after the catch block.\n}\n```\n3 involves \"unwinding the stack\".\nif no handler is found, program aborts.\n\n---\nWhat happens is a constructor throws an exception?\nThe object would be considered partially constructed.\nIs it safe for the destructor to run? no. The destructor will not run on partially constructed objects.\n\n```cpp\nclass C{...};\nclass D{\n  C a;\n  C b;\n  int *c;\n  public:\n    D(){\n      c = new int[10];\n      ...\n      if(~) throw something; //*\n    }\n    ~D(){delete [] c;}\n};\nD d;\n```\nAt \\*, the D object is not fully constructed. So **~D() will not run on d**.\nBut a and b are fully constructed, so their dtors will run.\n\n**So if a constructor throws, it has to be responsible for its own cleanup**.\n```cpp\nclass C{...};\nclass D{\n  C a;\n  C b;\n  int *c;\n  public:\n    D(){\n      c = new int[10];\n      ...\n      if(~){\n        delete []c;\n        throw something;\n      } \n    }\n    ~D(){delete [] c;}\n};\nD d;\n```\n\nWhat happens if a destructor throws?\nTrouble lol.\nBy default, the program aborts immediately.\nstd::terminate is called.\n\nIf you really want a throwing destructor, tag it with `noexcept(false)`.\nBut you really don't want a throwing destructor.\n\nYou can't have more than one active exception; the program will abort guaranteed. You can only play ball with one baseball I guess.\n","tags":[],"folderPathname":"/CS246E","data":{},"createdAt":"2019-10-01T14:13:04.903Z","updatedAt":"2019-12-05T01:42:16.102Z","trashed":false,"_rev":"deqEnWPYRdx"}