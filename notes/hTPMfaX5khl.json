{"_id":"note:hTPMfaX5khl","title":"Week 05","content":"## Week 05\n\n### Data representations and basic math operations\n\n#### Characters:\nASCII is 7 bits for 128 characters, with one extra bit for error checking in the front.\n\nUnicode is 16 bits per character.\n\nRemember, one **word** is 4 bytes.\n\n![ed717ad2.png](ed717ad2-kl2t950i.png)\n\nSo if this pattern is incorrect, we know there's an error.\n\n!!! note Useful powers\n$2^5 = 32$\n$2^{10} = 1K$\n$2^{20} = 1M$\n$2^{30} = 1G$\n!!!\n\nWe should use two's complement, because a sign bit is tedious, has two $0$s, etc.\n\nTwo's complement: let the MSB represent a power of **negative 2**, while the others represent powers of positive 2.\n\nTo negate in 2's complement, just invert all bits and add 1.\n\n---\n\nTo translate a two's complement number from say 4 bits to 8 bits, simply pad on the MSB side using the original **MSB**.\n\nAddition is now simple to define. Just use the old elementary school technique, and throw away the final carry if there is one. To subtract, just negate then add.\n\n!!! danger Overflow\nOverflow is a real concern here. Importantly, it can only occur if the operands have the same sign. If the result has the same sign, then there's no overflow. If the result has a different sign, then yes an overflow has occured.\n!!!\n\n## Building an Addition Circuit\nWe need **full adders** (thank you knowles).\n$$\nS = A \\oplus B \\oplus C\n$$\n$$\nC = AB + AC + BC_{in}\n$$\n\n![57334b1b.png](57334b1b-kl2t950i.png)\n\n## Logical shift\nThere are many shifts\n1. Arithmetic shift left or right\nCorresponds to multiplying or dividing by 2. Just move all the bits over by one, either left or right. Void space is assumed to be $0$.\n2. Circular Shift\nAny overflow just loops back around. Again, there's a left and a right variant.\n\n![18bc9e49.png](18bc9e49-kl2t950h.png)\n\n\n## Arithmetic Logic Unit (ALU)\n\n![30aeef49.png](30aeef49-kl2t950h.png)\n\nBut, we can improve this in a few ways:\n\n![d7058659.png](:storage/232ce97f-f29c-4c34-9cc2-be891b6d7939/d7058659.png)\n\nThis is a really cool little contraption.\nThis is the final design, with a bunch chained together for 64 bits:\n\n![d5cdc51b.png](d5cdc51b-kl2t950i.png)\n\nWhich can be represented as:\n\n![359102e9.png](:storage/232ce97f-f29c-4c34-9cc2-be891b6d7939/359102e9.png)\n\n---\n\n## Multiplication\n\n![a5de2fd2.png](:storage/232ce97f-f29c-4c34-9cc2-be891b6d7939/a5de2fd2.png)\n\nIt's just shifts and adds\n\n![6760b3f6.png](6760b3f6-kl2t950i.png)\n\n![e784d338.png](:storage/232ce97f-f29c-4c34-9cc2-be891b6d7939/e784d338.png)\n\n![2d305477.png](2d305477-kl2t950h.png)\n\nThere's another type of multiplier that's more efficient.\n\n---\n\n## IEEE Floating point bois\n\nWe need more than decimal numbers. We need floating points, and fractional values.\n\nWe hagve the mantissa (the significant digits) and the exponent. Note that for computers, it's natural to use base 2 for the exponent. So an example would be $1.01_2\\times2^4$.\n\nIn normalized binary, the **leading digit of significand is always 1**.\n\nNote that in binary, we can't always represent numbers exactly how they are. We can't represent $1.33$ exactly in binary scientific notation, and we also can't represent $1.1$. They just can't be accurately expressed as powers of 2.\n\n![cf1d895d.png](cf1d895d-kl2t950i.png)\n\n![1a23ce83.png](1a23ce83-kl2t950h.png)\n\nTypo in the above slide ^ \nSingle precision is `float32`.\n\nWe always **assume there's a leading 1** in our numbers, so we don't actually have to store it. The only exception to that statement is the number $0$. If an exponent is all zeros, that means the number is actually 0.\n\nThe $11111111$ exponent is also a special case, which is reserved for interpretting numbers that are not floating point (outside this course).\nSo we can represent exponents from $[00000001, 11111110]$.\n!!! danger Watch out for the exponent representation.\nIt's not 2's complement. It's $\\text{real exponent} = x - 127$, where $x$ is the 8 bits. It's always positive, and it's unsigned. Keep in mind, this is the **BINARY** exponent, so it's the $2^x$. It's not the $10^x$. \nWhy?\nBECAUSE ITS FAST FOR SORTING!\nIf we consider the **whole** floating point number as a 2's complement number, then we can actually sort effectively.\n!!!\nThere are FP registers, which are registers specifically interpretted as floats.\n\nTo convert from decimal fractional number to a binary fractional number, it's quite simple:\n1. multiply by 2.\n2. keep the non-fractional digit (it will be a 1 or 0)\n3. repeat until you're left with 0. (won't always be possible, that's a repeating fraction)\n\nThe list of digits you kept will be the corresponding binary fractional representation, $0.a_1a_2a_3...$.\n\nTruncation isn't that bad. First you normalize, and then you truncate. Don't truncate and then normalize; that's wasteful.\n\n!!! question How do I detect overflow?\nWell, the mantissa is no problem. You can just truncate it. Of course, you'll lose some precision, but it's not a big deal. The main issue is this: Can I represent an exponent that large (overflow) or small (underflow)?\n!!!\n\nFloating point addition is icky. It's more complicated than multiplication.","tags":[],"folderPathname":"/CS251","data":{},"createdAt":"2020-06-09T17:16:56.075Z","updatedAt":"2020-08-14T17:46:06.798Z","trashed":false,"_rev":"IAOA2Heb5f4"}