{"title":"L10: Virtual Memory","content":"### OS of the day:\n\n![](image-kl0ywr3d.png)\nUnix's main competitor.\n\nNot for everyday use.\nMore for inventory and such. It's a DB model.\n\nIt's now just a database.\n\n\n## Virtual Memory\n\nThis is the largest unit.\n\nWe've glossed over the address space\n\n\nWhen you go to load a program, it creates an address space. We need code space, heap space, and stack space. So here we go.\n\n![](image-kl0z8to5.png)\n\nCode, heap, and stack. The stack is at the back, moving _left_.\n\nBut we don't really want to give the process exact, physical addresses. That way, everyone thinks they start at 0. It makes it easier. It's also sketchy; if I know where I live physically, I could potentially access the address of my neighbour, snooping :eyes: on other programs. We could get into the kernel, compromising the entire system. So we don't want user programs to know where they live.\n\nAlso, if we assign physical addresses, we could fragment our memory. If the program doesn't have a physical address, then we can rely on non-contiguous blocks of memory.\n\n![](image-kl0zcwm5.png)\n\nSame program, running 3 times.\n![](image-kl0zh3ms.png)\n\nAnd you can see, these programs don't have contiguous blocks. These addresses are \"fake\", they're **virtual**. Good abstraction.\n\n\n![](image-kl0zlv32.png)\n\nWe only address **bytes**, we don't do **bit**-wise.  48 bits for address gives you 256 TB addressable.\n\n","tags":[],"folderPathname":"/CS350","data":{},"createdAt":"2021-02-11T14:31:43.285Z","updatedAt":"2021-02-11T14:59:50.898Z","trashed":false,"_id":"note:JXWL8N5mQ","_rev":"37-7041e4885f7e1d8ca112a96ca71f0990"}