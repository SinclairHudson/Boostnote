createdAt: "2019-09-25T16:48:20.057Z"
updatedAt: "2019-12-05T01:18:18.851Z"
type: "MARKDOWN_NOTE"
folder: "13f1477d1dab07e879ca"
title: "Problem 07: Tampering"
tags: []
content: '''
  ## Problem 07: Tampering
  ```cpp
  vector v;
  v.cap = 100; //sets the cap without allocating memory
  
  v.pushback(1); //will likely crash. The user has interfered with our datatype.
  ```
  Interfering with ADTs
  1) **Forgery** - creating an object without using a constructor function. Not possible since we wrote ctors
  2) **Tampering** - accessing the internals without using a provided interface function.
  
  !!! hint Invariant
  A statement that will always be true about an abstraction.
  !!!
  Stacks provide the invariant that the last item pushed is the first item popped.
  We need to secure the invariant for our ADTs, specifically for vectors:
  
  Vectors rely on the invariant that elements 0...cap-1 denote valid locations.
  
  And we can't guarantee this if the user interferes with our internals.
  
  Fix: Encapsulation
  !!! hint Encapsulation
  We will seal objects into "black boxes" to protect their fields.
  !!!
  
  #### vector.h
  ```cpp
  namespace CS246E{
    struct vector{
      private: //visible only within the vector class
        int *theVector;
        size_t n, cap;
      public: //visible to all (default)
        vector();
        size_t size() const;
        void pushback(int n);
    }
  }
  ```
  
  #### vector.cc
  ```cpp
    #include "vector.h"
    namespace{ //this no longer works, because it doesn't have access to v's internals.
      void increaseCap(vector &v){...}
    }
  ```
  
  Try again:
  #### vector.h
  ```cpp
  namespace CS246E{
    struct vector{
      private: //visible only within the vector class
        int *theVector;
        size_t n, cap;
      public: //visible to all (default)
        vector();
        size_t size() const;
        void pushback(int n);
      private:
        void increaseCap(); //now it's a private method
    }
  }
  ```
  
  #### vector.cc
  ```cpp
    #include "vector.h"
    namespace CS246E{ //no longer static (anonymous namespace)
      ...
      void vector::increaseCap(){...}
      ...
    }
  ```
  
  Structs provide public default access.
  It's better if the default access is private...
  We can't change struct, because C is still here.
  `class` is exactly like struct, but **private by default**.
  This is more *mysterious*, more classy. Classy people never overshare.
  
  #### vector.h
  ```cpp
  class vector{
    int *theVector;
    size_t n, cap;
    public:
      vector();
      ...
    private: //whitespace is merely convention
      void increaseCap();
  }
  ```
  ---
  A similar problem exists with linked lists.
  ```cpp
  Node n{3,nullptr}; //on the stack
  Node m{4,&n}; //this will oof, trying to delete something on the stack
  ```
  There used to be an invariant - next is nullptr or was allocated by new.
  
  ### 9/26/2019
  Need to make sure `&n` in the above code is nullptr, or allocated by new.
  Abstract further! We need to go deeper. We will encapulate node inside a "wrapper class".
  
  ```cpp
  class list{
    struct Node{ //nested class, useful for scoping
    //nobody can even say the word node outside of this class.
      int data;
      Node *next;
      //methods
    };
    Node *theList;
    list():theList{nullptr}{}
    ~list(){delete theList;}
    size_t size() const;
    
    void push_front(int n){theList=new Node{n,theList};}
    void pop_front(){
      if(theList){
        Node *tmp=theList;
        theList=theList->next;
        tmp->next=nullptr;
        delete tmp;
      }
    }
    const int &operator[](size_t i)const{
      Node *cur = theList;
      for(size_t j = 0; j < i, ++j, cur = cur->next);
      return cur->data;
    }
    int &operator[](size_t i){...}
  }
  ```
  And see because the nodes are private, the client cannot access any pointers. Invariant is secured.
  
  
  
  
'''
linesHighlighted: [
  14
]
isStarred: false
isTrashed: false
