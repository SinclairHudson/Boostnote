{"_id":"note:VWez6q7vxaY","title":"Problem 05: Moves","content":"## Problem 05: Moves\nConsider:\n```cpp\nNode plusOne(Node n){ //maps +1 across the list values\n  for(Node *p=&n;p;p=p->next){\n    ++p->data;\n  }\n  return n;\n}\n\nNode n{1, new Node{2, nullptr}};\n\nNode m = plusOne(n); //copy ctor is being called.\n\n```\n* but what is `other` here if we feed it into our copy constructor? reference to what?\n* there's a temporary object, created to hold the results of plusOne.\n* other is a ref to this temporary\n* copy ctor deep-copies from this temporary\n\nBut why copy from something when we can steal from it? Why copy from the temp when it's going to die soon after? It's wasteful to deep copy from the temporary object. We save the cost of a copy if we steal. But if we want to steal, we have to have a mechanism that determines if something is going to die soon. lul. Need to be able to tell whether `other` is a ref to a temporary object or a standalone object.\n\n!!! note R-value references\nA reference to something that can be on the right side of an equals sign.\nA reference to a **temporary object**, something that will die soon.\n`Node &&` is the type. It looks like a ref to a ref, and that's illegal, but that's effectively what it means.\n!!!\n`Node &&` is a reference to a temporary object (rvalue) of type Node.\nSo we need a version of the ctor that takes a `Node &&`;\nThis is known as a **move constructor**. Moving is stealing.\n```cpp\nNode::Node(Node &&other): data{other.data}, next{other.next}{\n  other.next=nullptr; //IMPORTANT\n}\n```\nWe need to make sure that the other also doesn't have the data. This is because **we don't want other's destructor to get rid of it**. You can imagine if we left `other.next` as is, it would destroy our `Node`.\n\nSimilarly:\n```cpp\nNode m;\nm = plusOne(n); //assignment from a temporary.\n```\nMove assignment operator:\n```cpp\nstruct Node{\n...\nNode &operator = (Node &&other){ //steal other's data\n  //use the swap operator. This allows us to destroy our old data.\n  using std::swap;\n  swap(data,other.data);\n  swap(next,other.next);\n  return *this.\n  }\n}\n```\nBut we should be able to combine copy/move assignment:\n```cpp\nstruct Node{\n...\nNode &operator = (Node other){ //pass by value\n//invokes copy constructor if arg is an lvalue, invokes move constructor is arg is an rvalue. Copy iff arg is an lvalue.\n  swap(other);\n  return *this.\n  }\n}\n```\nCopy and swap can be expensive, so sometimes a custom operator is better.\n\nConsider:\n```cpp\nstruct Student{\n  std::string name; //string is a class\n  Student (const std::string &name):name{name}{}\n  //copies arg into field (copy ctor)\n  //but what if name refers to an rvalue?\n}\n```\n\n```cpp\nstruct Student{\n  std::string name;\n  Student (const std::string name):name{name}{}\n  //copies if name is an l-value, and moves if name is an r-value.\n  //but it get copied twice, because pass by value.\n  //name may refer to an rvalue, but name is an lvalue.\n  //we want the assignment to actually be a move. we force it, because a copy has already been done\n}\n```\n\n```cpp\nstruct Student{\n  std::string name;\n  Student (const std::string name):name{std::move(name)}{}\n  //std::move doesn't actually move anything. It just says \"treat this thing as if it were an r-value.\"\n  //now we have a move construction.\n  \n  Student(const Student &&other)://move constructor\n    name{std::move(other.name)}{}\n  \n  Student &operator=(Student other){ //uified assignment\n    name=std::move(other.name);\n    return *this;\n  }\n};\n```\nIf you don't define move operations, copy operations will be used. If you do define them, they will replace copy operations when the argument is a temporary (rvalue).\n\n## Copy/Move Elision\n\nElision means to leave something out.\n```cpp\nvector makeAVector(){\n  return vector{};\n}\nvector v = makeAVector(); //copy constructor?\n//Tried in g++ - just the basic constructor.\n```\nIn some circumstances, the compiler is allowed to skip calling the copy/move constructors. In this case, it's smart to realize using the default constructor is better than making a temporary and then moing it to `v`.\n\n`makeAVector` writes its result directly into the space occupied by v in the caller, rather than copy it later.\n```cpp\nvector v = vector{}; //formally a basic construction and a copy/move construction\n\n//the following are completely identical, because the compiler is required to elide this copy/move construction, so basic ctor only.\nStudent s = Student{70,80,90};\nStudent s{70,80,90};\n```\nEg\n```cpp\nvoid doSomething(vector v){...} //pass-by-value; copy/move ctor\ndoSomething(makeAVector());\n//result of makeAVector written directly into the param - no copy.\n```\nThis is allowed, even if dropping ctor calls would change the behaviour of the program. (eg printing in the constructor)\n\nIf you need all of the ctors to run, you do have the option to turn off elision.\n\n`$ g++14 -fno-elide-constructors ...`\n\nNot recommended, because it can slow the program down dramatically.\n\n### Rule of 5 (Big 5)\nIf you need to customize any one of\n* Copy ctor\n* Copy assignment\n* Dtor\n* Move ctor\n* Move assignment \n\nThen you usually need to customize all 5.\n\n##### From now on, assume that vector and node have the big 5 defined.\n\n","tags":[],"folderPathname":"/imported/CS246E","data":{},"createdAt":"2019-09-19T15:05:16.053Z","updatedAt":"2019-12-04T22:26:39.617Z","trashed":true,"_rev":"5rZJF3e5wTM"}