createdAt: "2019-10-27T20:10:27.153Z"
updatedAt: "2019-12-04T21:40:41.139Z"
type: "MARKDOWN_NOTE"
folder: "13f1477d1dab07e879ca"
title: "Problem 02: Linear Collections and Modularity"
tags: []
content: '''
  ## Problem 02: Linear Collections and Modularity
  Let's make a linked list structure!
  
  #### node.h
  ```cpp
  struct Node{
    int data;
    Node *next;
  };
  
  size_t size(Node *n); //function
  ```
  #### node.cc
  ```cpp
  #include "node.h"
  
  size_t size(Node *n){
    size_t count = 0;
    for()Node *cur=n; cur; cur = cur->next){
      count++;
    }
    return count;
  }
  ```
  And now we can use this module in main.
  #### main.cc
  ```cpp
  #include "node.h"
  
  int main(){
    Node *n = new Node;
    n->data = 3;
    n->next = nullptr;
    
    Node *n2 = new Node{2, n};
    Node *n3 = new Node{4, new Node{5, nullptr}};
    
    delete n; //ok
    delete n2; //ok
    delete n3->next;
    delete n3;
    
    // alternatively,
    while(n3){ //procedurally deletes all nodes in a linked list.
      Node *tmp = n3;
      n3 = n3->next;
      delete tmp;
    }
  }
  ```
  
  ---
  
  What happens if we do
  ```cpp
  #include "node.h"
  #include "node.h"
  ```
  **This won't compile**, because we're inserting the definition twice. We're defining the same struct twice, and that isn't allowed. 
  
  ### C Preprocessor
  
  The C preprocessor is a program that transforms code before handing it off to the **compiler**.
  It's responisble for `#include` statements. `#` signifies a preprocessor command.
  
  You can also do things like
  `#define VAR VALUE`, which literally just replaces every instance of `VAR` with `VALUE`.
  So you could do something like
  ```cpp
  #define MAX 10;
  ......
  int main(){
    int x[MAX];
  }
  ```
  And this would compile. 
  You can even talk to the preprocessor through the command line.
  ```
  $ g++14 -D MAX=10 myprogram.cc -o exec
  ```
  The above command will accomplish the same thing as `#define MAX 10;`.
  
  We can use the C Preprocessor to solve our above problem of including the same file twice. This problem could come up in complex problems, where two linked files both need access to node.h.
  
  #### node.h
  ```cpp
  #ifndef NODE_H // this is true if NODE_H is not defined.
  #define NODE_H // define NODE_H
   ... actual file contents go here
   ....
  #endif
  ```
  The **include guard** allows us to include the same module twice, because it'll simply get ignored on the second pass.
  
  !!! note Include Guards
  Always put include guards in header files. There's no reason not to, and will save you from **linking errors**.
  !!!
  
  !!! danger Compiling header files
  NEVER compile a .h file. It doesn't make sense. Just include them in source files and compile those.
  !!!
  
  !!! danger Including source files
  NEVER include a .cc or .cpp file. You don't need to, and it makes linking way more confusing. 
  !!!
  
  Now, what if you have two structures that have the same name, but are different? A good example would be a Node struct from a linked list and a Node struct from a binary tree. The solution, as you may have guessed, is **namespaces**:
  
  #### list.h
  ```cpp
  #ifndef LIST_H
  #define LIST_H
  
  namespace List{
    struct Node{
      int data;
      Node *next;
    };
    ...
  }
  #endif
  ```
  
  #### tree.h
  ```cpp
  #ifndef TREE_H
  #define TREE_H
  
  namespace Tree{
    struct Node{
      int data;
      Node *left;
      Node *right;
    };
    ...
  }
  #endif
  ```
  
  #### main.cc
  ```cpp
  #include "list.h";
  #include "tree.h"; //ok
  
  int main(){
    List::Node *ln = new List::Node{1,nullptr};
    Tree::Node *tn = new Tree::Node{1,nullptr,nullptr};
    
    ...
    delete ln;
  }
  ```
  
  !!! note Namespaces
  Namespaces are **open**. This means that anyone can add functions to any namespace. The only exception is the `std` namespace.
  !!!
  
  !!! note Unnamed Namespaces
  There's a weird trick with unnamed namespaces; they're private. Nobody outside the namespace can explicitly call functions in an unnamed namespace. However, these methods can still be used through other methods. We'll see an example in the next problem.
  !!!
'''
linesHighlighted: [
  4
  58
]
isStarred: false
isTrashed: false
