{"title":"L08: Processes","content":"![](image-kkqyo37n.png)\n\n## Processes and the Kernel\n\n![](image-kkqyrlnd.png)\n\nA process is a structure. It has one address space, an array of threads (at least one).\nAnd then there are resources assigned to the process. Things like port numbers. It's the whole **execution environment**.\n\nLook at `proc.h` in the kernel. Never use the name of a process to identify it - **names are not unique**.\n\n![](image-kkqyxdze.png)\n\nThis is incomplete (complete it in A2).\n\nProcesses can't communicate between each other, like threads can. Processes have isolated address spaces; they can't share variables.\nInter-process communication isn't feasible, without assistance from the kernel.\n\nA Process is running if one thread (or more) is running.\nA Process is blocked if all threads are blocked.\nA Process is a zombie if it's hanging around with no threads.\nA Process is ready if all the threads are ready.\n\nTOP babey!\n\n![](image-kkqz4fma.png)\n\nEach chrome tab is its own process.\n\nIt's hard to interact with processes in Windows. WINDOWS. Who uses Windows?\n\n![](image-kkqzdw5s.png)\n\nfork is a clone, in a parent-child relationship.\n![](image-kkqzi1j2.png)\n\nBut we need a way to differentiate between parents and children. They have different PIDS.\n\nThe parents and children __do not share the address space__. \n\nwaitpid waits for another process to terminate, but only for your children. You want to know if they completed their mission, and if they left a message when they died. `_exit` leaves behind information. So when `_exit` is called, you become a zombie\nto relay that information to a parent that calls `waitpid`.\n\n![](image-kkqzs0r1.png)\n\nIn os161, every process can only have one thread.\n\nWhen you call waitpid, you can just have that thread pause, or all the threads in the process pause and wait for the child to die.\n\n![](image-kkqzwit0.png)\n\n`execv` is kind of weird.\n\nBut `execv` might fail. Depends on the next program.\n\n![](image-kkqzz89y.png)\n\nIf `execv` succeeds, then the following code gets destroyed. the process is successfully hijacked.\n\nHadoop.\n\n![](image-kkr023fr.png)\n\n`execv` can't override parental relationships. the child is still the child of the parent, because the PID is still the same.\n\nYou can only call waitpid on children. You only care about the children.\n\nWhen the parent dies, the children don't also die. They continue. If the parent changes their program with `execv`, they can still call waitpid on its children.\n\nRemember, parents and children don't share address spaces, so shared variables are not shared.\n\nWe can represent processes in a _process tree_.\n\n## System Calls\n\n![](image-kkr0hho5.png)\n\nThe user is not permitted to do system calls themselves. The application has to ask the kernel to do those things for it. This is good abstract design, so that the application is not hardware or file-system dependent.\n\n`printf` and `cout` are system calls. They're slow.\n\n![](image-kkr0p7ww.png)\n\nThis designation is at the CPU level. It's not just an abstraction, or a convention.\nIt's hardware bound.\n\n![](image-kkr0rlrz.png)\n\nOverclocking and underclocking are, of course, privileged abilities.\n\n![](image-kkr0w9xe.png)\n\n\n\n\n","tags":[],"folderPathname":"/CS350","data":{},"createdAt":"2021-02-04T14:32:57.715Z","updatedAt":"2021-02-04T15:37:05.988Z","trashed":false,"_id":"note:sCbpwr-kA","_rev":"82-44180774b5520bf2c1d597ae036adba1"}