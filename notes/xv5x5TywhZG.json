{"_id":"note:xv5x5TywhZG","title":"Problem 27: Resolving Method Overrides at Compile-time","content":"## Problem 27: Resolving Method Overrides at Compile-time\n\nRecall: Template Method Pattern:\n\n```cpp\nclass Turtle{\n  public:\n    void draw(){\n      draw Head();\n      draw Shell();\n      drawFeet();\n    }\n  private:\n    void drawHead();\n    virtual void drawShell();\n    void drawFeet();\n}\n\nclass RedTurtle: public Turtle{\n  void drawShell() override;\n};\n```\n\nConsider:\n```cpp\ntemplate<typename T> class Turtle{ //turtle wil know what its subclass will be\n  public:\n    void draw(){\n      void drawHead();\n      static_cast<T*>(this)->drawShell(); //bruh\n      void drawFeet();\n    }\n  private:\n    void drawHead();\n    void drawFeet();\n};\n```\nSo now the subclasses look a little something like this:\n```cpp\nclass RedTurtle: public Turtle<RedTurtle>{\n  friend class Turtle;\n  void drawShell();\n}; //no virtual methods, no vtable lookup.  \n\nclass GreenTurtle: public Turtle<GreenTurtle>{\n  friend class Turtle;\n  void drawShell();\n};\n```\nGreat! So why don't we do this all the time? The drawback now is that redTurtle and greenTurtle are not related to each other. They don't share a parent anymore. So you can't store a mix of them in a container.\n\nYou could give Turtle a parent:\n```cpp\ntypename <typename T> class Turtle: public Enemy{~~~~~};\n```\nAnd then you could store Enemy pointers in the same array. But it can't access the draw method. So you could give Enemy a virtual draw method. Which would defeat the purpose.\n\n\n## INCOMPLETE","tags":[],"folderPathname":"/imported/CS246E","data":{},"createdAt":"2019-11-26T15:35:50.138Z","updatedAt":"2019-11-26T15:51:20.444Z","trashed":true,"_rev":"gVkXvr47v9S"}