{"_id":"note:saWDMe8LLvQ","title":"Problem 12: A vector of Posns","content":"## Problem 12: A vector of Posns\n```cpp\nstruct Posn{\n  int x, y;\n  Posn(int x, int y):x{x},y{y}{}\n};\n\nint main(){\n  vector<Posn> v; //won't compile! Y tho.\n}\n```\nTake a look at vector's ctor:\n```cpp\ntemplate <typename T> vector<T>::vector():n{0},cap{1}, theVector{new T[cap]}{}\n```\nWell, C++ always calls a constructor when creating an object. Which constructor gets called? Well, the default constructor, because it doesn't know what else to do. So it will call T{}, and Posn doesn't have a default constructor. So it crashes.\n\nSo how can we create a vector of Posns? Well we can make a default constructor, but that doesn't always make sense. What's the default name of a Person?\n\nWe need to **seperate the allocation of memory from the construction of the object**.\nThat's the first step in object creation.\n\nAllocation:\n`void *operator new(size_t)` This is like malloc. it allocates size_t bytes with no initialization. returns a `void *` pointer to the beginning of the memory.\n\n!!! danger Difference with C\nC: `void *` implicitly converts to any pointer type\nC++: the conversion requires a cast.\n!!!\n\nInitialization: \"placement new\"\n\n`new (addr) type` - constructs a new object at the specified address.\n**This does not allocate memory**. It uses memory that you already have.\n```cpp\ntemplate <typename T> class vector{\n  ~~~~~\n  public:\n    vector(): n{0},cap{1},theVector{static_cast<T*>(operator new (cap*sizeof(T)))}{}\n    vector(size_t n, T x = T{}): n{n}, cap{n}, theVector{static_cast<T*>(operator new(cap *sizeof(T)))}{\n      for(size_t i = 0; i<n; ++i){\n        new(theVector+i) T (x); //placement new, not operator new\n      }\n    }\n    ~~~~~\n    void push_back(T x){\n      increaseCap();\n      new (theVector + (n++)) T (x);\n    }\n    ~~~~~~ //reserve and increase_cap will also have to change.\n    void pop_back(){\n      if(n){\n        theVector[n-1].~T(); //Must explicitly invoke the destructor.\n        --n;\n      }\n    }\n    void cleanup(){\n      if(n!=0){\n        for(size_t i = n-1; i>=1; --i){\n          theVector[i].~T();\n        }\n      }\n      if(n>=1) theVector[0].~T(); //size_t is unsigned, so we're always >= 0.\n      n=0;\n    }\n    ~vector(){\n      cleanup();\n      operator delete(theVector);\n    }\n};\n```\n","tags":[],"folderPathname":"/CS246E","data":{},"createdAt":"2019-10-03T14:36:22.025Z","updatedAt":"2019-12-05T01:55:29.459Z","trashed":false,"_rev":"e5p_-WdKI9R"}