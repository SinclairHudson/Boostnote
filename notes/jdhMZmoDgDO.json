{"_id":"note:jdhMZmoDgDO","title":"Problem 01: Input and Output","content":"## Problem 01: Input and Output\n\nLet's start with the basics.\n\n`./programname` will run your program, as long as it is in the current directory. the file path is a command.\n\n### Input\nYou can provide input in two ways:\n1) Command argurments\n2) `std::cin` - \"standard input\" typing input after executing the program.\n\nCommand arguments look like `./programname arg1 arg2 arg3`, while `std::cin` just means you run the program and typing something, then pressing enter gives the input to the program.\n\nRemember, arguments are actually written to the memory, and they can be accessed inside the main function of the program. `argv[0]` is `./programname`, `argv[1]` is `arg1`, etc. `argv` has length `argc`.\n\n### Output\nOutput comes in many forms, but most of the time it will be to print something to the screen. Printing is actually fairly expensive, so C++ gives you two options:\n1. `stdout` - buffered\n2. `stderror` - not buffered\n\n\n### Redirects\nIn the linux command line, we can use < and > to convey where we want the output to go.\n\n`./program < inFile > outFile > errorFile` will run the program, which will use inFile as input, \"print\" the output to the outFile, and print errors to the errorFile.\n\n\n### Compilation\n\nTo compile a program, use the command `gcc -std=c++14 -Wall program.cc -o exec`.\nThis will convert program.cc into exec, which can be run. -Wall gives you all compiler warnings.\n\n### File Access\n```cpp\n#include <iostream> //for files\n\nint main(){\nint x, y;\n\nstd::cin >> x >> y;\nstd::cout << x + y << std::endl;\n\n}\n```\n`std::cin`, `std::cout`, etc are stream types. `<<` is an operator, which populates or prints as a side effect, and returns the stream so they can be chained together. That's why the second works.\n\nIf we want to actually read from a file, we can do:\n```cpp\nstd::ifstream f{\"filename\"}; //i f stands for input file. there's also ofstream, which is output file stream.\nchar c;\n\nwhile(f >> c){ // pull characters from f and puts them in c. returns bool if successful\nstd::cout << c;\n}\n```\nBut this skips whitespace. If we want to preserve white space, we have to insert the following: `f >> std::noskipws`.\n\nConsider:\n```cpp\n#include <iostream>\n\nusing namespace std;  // Avoids having to say std::\n\nvoid echo (istream f) {\n    char c;\n    f >> noskipws;;\n    while (f >> c) {\n        cout << c;\n    }\n}\n\nint main(int argc, char *argv[]) {\n    if (argc == 1) {\n        echo(cin);\n    } else {\n        for (int i = 1; i < argc; ++i) {\n            ifstream f{argv[i]};\n            echo(f);\n        }\n    }\n}\n```\n\nThis actually won't even compile. Why? It's not a type mismatch, because ifstream is a type of istream. It's actually because **streams can't be copied**. When we pass it to echo, it gets copied. \nOk, so we should use a pointer to `f`? Not really. What we need is called a **reference**.\n\n!!! note reference\nReferences are similar to pointers, but they have auto dereferencing. So it's like an alias for the same object; a different name.\n```cpp\nint y = 10;\nint &z = y; //z is a reference to y\nz = 12; //y is also changed\n```\nz is called an **l-value reference** to y. l-value references must be initialized to something that actually has an address. So, for example,\n\n```cpp\nint &z = 12 + 14;\n```\nDoesn't work, because 12 + 14 doesn't have an address.\n!!!\n\nThe best use for references is to use them in function parameters. In the above code, if we were to do \n\n```cpp\n#include <iostream>\n\nusing namespace std;  // Avoids having to say std::\n\nvoid echo (istream &f) { //NEW\n    char c;\n    f >> noskipws;;\n    while (f >> c) {\n        cout << c;\n    }\n}\n\nint main(int argc, char *argv[]) {\n    if (argc == 1) {\n        echo(cin);\n    } else {\n        for (int i = 1; i < argc; ++i) {\n            ifstream f{argv[i]};\n            echo(f);\n        }\n    }\n}\n```\n\nThen it would work, because we're no longer copying f, just passing an alias. `echo` is now pass by reference, not pass by value. This is also handy because we don't spend time copying parameters if they don't need to be copied. However, **passing by reference means that the functon can mutate the object**. This is just like pointers. If we want to prevent that, we can pass a `const` reference, like so:\n\n```cpp\nint h(const int &n){ \n~~~~~~ //we can't modify n here.\n}\n```","tags":[],"folderPathname":"/imported/CS246E","data":{},"createdAt":"2019-10-27T20:10:13.308Z","updatedAt":"2019-12-04T21:17:21.405Z","trashed":true,"_rev":"pMhFMXqc8qB"}