{"_id":"note:_jp0uU12BbJ","title":"Problem 22: I want to know what kind of book I have.","content":"## Problem 22: I want to know what kind of book I have.\n\nFor simplicity, assume we have the old hierarchy of Book -> Text, Book -> Comic\n\nThe C++ casting operators:\n1) `static_cast`\n2) `reinterpret_cast`\n3) `const_cast`\n4) `dynamic_cast`\n\nIn C:\n```c\n(type) expr;\n\nint *p;\nint q = (int) p;\n```\n\nThis forces `expr` to be treated as type `type`.\nThis is so unsafe, you can make very few guarantees. \n\n\n### `static_cast`\nThe good one. For conversions with well-defined semantics.\n\n```cpp\nvoid f(int a);\nvoid f(double b);\nint x;\nf(static_cast<double>(x));\n```\nI know what it means when I convert a double to an int and vice versa. It's pretty safe.\nYou can also convert a superclass pointer to a subclass pointer.\n\n```cpp\nBook *b = new Text{...};\nText *t = static_cast<Text *>(b); t->getTopic(); //you have to KNOW this will work\n```\n\nIf this doesn't work, we have undefined behaviour. The compiler has faith in you.\n\n### `reinterpret_cast`\nFor casts without well-defined semantics.\nUnsafe, implementation dependent.\n```cpp\nBook *b = new Book{...};\nint *p = reinterpret_cast<int *>(b); //suuper sketchy lmao\n```\nYou put your faith in the compiler with this one.\n\n### `const_cast`\nFor adding/removing const. It's the only C++ cast that can \"cast away\" const.\nA const cast cannot change the reality of the read-only memory where a constant is stored.\n```cpp\nvoid g(Book &b);\nvoid f(const Book &b){\n  ...\n  g(b) // g doesn't make the promise that it won't change b, so it's not allowed. \n  //but let's say we know that g doesn't modify b.\n  g(const_cast<Book&>(b));\n  ...\n}\n```\n\n### `dynamic_cast`\n\n```cpp\nBook *b= ~~~~~~~~~~~~~~~~~~;\n\nText *t = dynamic_cast<Text *>(b);\n```\nWhat if we don't know whether b points to a Text?\n`static_cast` is not safe.\nIf `*b` is a Text or a sublass of Text, cast succeeds, t points to the object. If not, t = nullptr.\n\n```cpp\nif(t){...t->getTopic()...}\nelse ... //not a text\n```\n\nDynamic reference casting:\n```cpp\nBook *pb=~~~~~~~~~~~~~~~~~~~~~~~~~;\nText &t = dynamic_cast<Text&>(*pb);\n```\nIf \\*pb is a Text - OK\nelse, throws std::bad_cast\n\n!!! note Dynamic Casting\nDynamic casting works by accessing an object's **Runtime Type Information (RTTI)** - this is stored in the **vtable** for the class. You can only use `dynamic_cast` on objects with at least one virtual method.\n!!!\n\nDynamic reference casting offers a possible solution to the polymorphic assignment problem.\n```cpp\nText &Text::operator=(const Book &other){ //virtual\n  Text &textOther = dynamic_cast<Text &>(other); //throws if other is not a text.\n  if(this == &other) return *this;\n  Book::operator=(other);\n  topic = textOther.topic;\n  return *this;\n}\n```","tags":[],"folderPathname":"/CS246E","data":{},"createdAt":"2019-10-29T15:16:58.477Z","updatedAt":"2019-10-31T15:04:17.808Z","trashed":false,"_rev":"orHt7xY0LuL"}