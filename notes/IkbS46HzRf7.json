{"_id":"note:IkbS46HzRf7","title":"Week 06: SRAM/DRAM","content":"# Week 06: SRAM/DRAM\nThis isn't testable this term.\n\nThere's a memory hierarchy:\n1. Registers\n2. Caches\n3. Main memory (RAM)\n4. Disk storage\n\nRAM has chip select bits, because it's made up of multiple chips. There's a highway from RAM to the processor: The data bus.\n\nBut not all the data can go through the data bus at the same time! So we need a mechanism to be like a traffic conductor.\n\n\n![d7a91595.png](d7a91595-kl2ssw8k.png)\n\n![95a0838b.png](95a0838b-kl2ssw8j.png)\n\nSo it's basically a memory MUX.\n\nSo here's a bigger example about SRAM:\n\n![614f7f76.png](614f7f76-kl2ssw8j.png)\n\n\n### DRAM\n\nUses capacitors to store data. So we don't need 6 transistors per bit. However, capacitors discharge over time. So we recharge/refresh the caps thousands of times per second. But collisions are actually relatively small with the main clock cycle. So it's really not that bad. \n\n![8ab01d6e.png](8ab01d6e-kl2ssw8j.png)\n\n### Single-Cycle Processor\n\nThis is a very important unit.\nPC is a 64 bit address, and remember all our data is 64 bit.\nData Path = CPU\n\n1. PC Fetches the instruction\n2. Calculate PC+4 (don't write yet)\n3. Read from 2 registers (can ignore 1)\n4. Compute Something\n5. Write something into registers or use the result to index memory.\n\nHow do we specify where we need to save and what we need to compute and what we need to read?\nWell, there's an instruction breakdown just like MIPS. But the actual groupings are completely different.\n\nThe **ALU Control Unit** interprets the opcodes and tells the ALU needs to do.\nThe opcodes are actually variable in length... wtf?\nThe **Control Unit** takes the opcode and outputs control bits, to modify the Data Path's behaviour.\n\n--- \n# Single Cycle Data Path:\n\n![3c6ceece.png](3c6ceece-kl2ssw8j.png)\n\n![c27d6699.png](c27d6699-kl2ssw8j.png)\n\nHere it is. We'll do a bit of explanation and then go through each of the instruction types individually. \n\n### Control\nControl reads the opcode of the instruction and then has a bunch of outputs. These outputs control the operation of the single cycle.\n\n### Registers\nThe registers are at the center. We always read 2 registers, even if we're only going to use one. 5 bits go right from the instruction into the write register portion, specifying what register to write to.\n\n### Sign-Extend\nExtends immediate values in the instruction to 64 bit numbers, so that they can be added by the main ALU.\n\n### Data Memory\nControls what's read and written to data memory. You can see that it has the ability to read and write data, based on the control bits.\n\n### ALU Control\nTakes parts of the instruction and instructs the main ALU what to do.\n\n---\n\n\nRemember, ARM has 5 command types:\n* R-Format\n* I-Format\n* D-Format\n* B-Format\n* CB-Format\n\n![173fff57.png](173fff57-kl2ssw8j.png)\n\n#### R-format\n\nAll R-formats specify the instruction bits in the exact same way. The only difference then is what the main ALU does. This is dictated by the **ALU control unit**, which reads in the opcode. Opcodes have 4 **function bits**, which are passed to the ALU controller to specify which operation needs to be performed that cycle.\n\nThere is one exception: `SSL Rd, Rn, #imm`. This instruction takes the value of X2, shifts the bits to the left by `#imm`, then saves the result in `X1`. Rm is simply set to 0 and not used in this case. The immediate value in this instruction is specified using the shamt section of the instruction. Otherwise, this section is ignored. it's 6 bits, which works because registers store 64 bits.\n\n#### I-format\n\nThese instructions all specify a 12-bit *unsigned* immediate value. This value is added or subtracted from Rn. To achieve this, the 12 bit value must be sign-extended to 64 bits (0 padded because unsigned). It's always 0 padded, and these are the only values that are not traditionally sign-extended, as if they were 2's comp.\n\n#### D-format\n\nIn a d-format, the opcode will either have a value of 1986 or 1984, for LDUR or STUR respectively.\nImportantly, the DT address section is a 9-bit two's complement number, so it can be negative.\nThe op section isn't used in this course.\nRemember, Rn + address is always a **multiple of 8**.\n\n#### B-Format\n\n#### CB-Format\n\n---\n\n![c3d6fe74.png](c3d6fe74-kl2ssw8j.png)\n\n\n","tags":[],"folderPathname":"/imported/CS251","data":{},"createdAt":"2020-06-20T14:48:45.330Z","updatedAt":"2020-08-14T17:46:01.158Z","trashed":true,"_rev":"UP3k9q3OZHN"}