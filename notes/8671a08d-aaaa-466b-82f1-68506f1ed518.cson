createdAt: "2019-10-29T14:00:35.672Z"
updatedAt: "2019-10-29T15:43:00.738Z"
type: "MARKDOWN_NOTE"
folder: "13f1477d1dab07e879ca"
title: "Problem 19: I'm leaking!"
tags: []
content: '''
  ## Problem 19: I'm leaking!
  
  Consider:
  ```cpp
  class X{
    int *a;
    public:
      X(int n):a{new int{[n]}}{}
      ~X(){delete []a;}
  }
  
  class Y: public X{
    int *b;
    public:
      Y(int n, int m):X{n}, b{new int[m]}{}
      ~Y(){delete [] b;}
  }
  ```
  Ok. Y's destructor will call X's destructor. (Step 3);
  
  ```cpp
  X *px = new Y{3,4}; //normal. pointing a parent pointer at a child object.
  delete px;
  ```
  The above code leaks. but why? X's destructor is running, not Y's. So the extra memory that Y takes up will be leaked. 
  
  We need to make the destructor **virtual**.
  ```cpp
  class X{
    int *a;
    public:
      X(int n):a{new int{[n]}}{}
      virtual ~X(){delete []a;} //fixes
  }
  ```
  
  Always make the destructor virtual in classes that are meant to be superclasses. Even if the destructor does nothing. You never know what the subclass might do. Si you need to make sure its destructor gets called. If a class is not meant to be a superclass, no need to incur the cost of virtual methods needlessly. leave the destructor non-virtual.
  
  Declare the class **final** if you want to prevent subclassing.
  ```cpp
  class X final{ //cannot be subclassed
    int *a;
    public:
      X(int n):a{new int{[n]}}{}
      virtual ~X(){delete []a;} //fixes
  }
  ```
  ---
  
'''
linesHighlighted: []
isStarred: false
isTrashed: false
