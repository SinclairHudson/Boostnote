{"_id":"note:XtigwukFd1p","title":"M9: String searching (grep)","content":"# M9: String searching (grep)\n\n---\n## Rabin-Karp Fingerprint algorithm\n\nUse hashing to elim guesses\n\nCompute a hash function for each ghuess, then compare with pattern hash, If they're not equal, then it can't be a match. Hashes ideally are one-to-one (injective), but that's not always possible.\n\n![15a03f30.png](15a03f30-kl2ssw8g.png)\n\nWhen you get a match, you have to check that it's actually a match. However, it never misses a match.\n\nHowever, running is still $\\Theta(mn)$.\n\nHow to improve? The key is to **use the previous hash to compute the next hash**. This will take constant time, regardless of the length $m$. You have to get funky with the hash function, and use the previous hash value.\n\n![45fa8647.png](45fa8647-kl2ssw8h.png)\n\nRemember, modulus should be a huge prime! This decreases the probability of collisions in our hash.\n\nUsing this method, the expected running time is now $O(m+n)$. The worst case is $\\Theta(mn)$, but it's crazy unlikely. This is the case where all the hashes line up and are the same as the target hash. You have to check them all, all to the very last character.\n\n---\n\n## Boyer Morre Alg\n\nThe main idea is to move backwards when checking a guess. When we fail, we can view the character we failed on and see if it occurs in our pattern. If it doesn't well then we can skip all the guesses that contain this character.\n\nTo do this efficiently, for each letter in the alphabet, we need to keep track of the **last occurence** of that character in our search string. For characters that don't occur in the search string, they have an index of $-1$.\n\nSo when updating our shift, $k \\leftarrow max\\{1, k+(j-L(\\text{mismatched char of T}\\}))$.\n\n![05e5a6e5.png](05e5a6e5-kl2ssw8g.png)\n\n![5ed88577.png](5ed88577-kl2ssw8h.png)\n\n![922a4d30.png](922a4d30-kl2ssw8i.png)\n\n---\n\n### String matching using DFA\n\nWe create a DFA with $m$ states where m is the length of our target substring.\n\nThe transitions are the characters in the target substring.\n\n![45a59237.png](45a59237-kl2ssw8h.png)\n\nThe above is actually an NFA. (look at the first node). But evaluating the NFA is actually pretty slow.\n\nThis is basically the brute force algorithm reframed.\n\nChecking a DFA is actually faster. So we can convert the DFA to an NFA. The bad news is that now we have a very complicated DFA.\n\n![8a38d601.png](8a38d601-kl2ssw8h.png)\n\nThe size of the DFA is in space $O(m|\\Sigma|)$.\nWe can run the DFA pattern matching in $\\Theta(n)$, because you just go linearly.\n\n---\n\n## Knuth-Morris-Pratt Algorithm\n\nThere's a new type of transition \"failure\".\n\nit combines the uniqueness of the DFA and the few arcs of NFA.\n![a458796a.png](a458796a-kl2ssw8i.png)\n\nThe failure transition is the \"else\". It's taken only if no other transition works.\nWe can actually store all the failure arcs in an array of length $m$, because there's one state per character, and there's one failure per state. A failure in state $i$ means you should go to state $F[i]$.\n\n![de17ca6b.png](de17ca6b-kl2ssw8i.png)\n\nBut how do we construct $F$?\n\n---\n\nIt's a matter of shifting the maximium amount, based on what you've already seem in the pattern. \nYou can eliminate a shift if that prefix of $P$ is not a suffix of $P[1,...j]$.\n\nWe want the longest prefix $P[0, ... l - 1]$ that is a suffix of $P[1...j]$.\n\nThe $l$ characters of this prefix are matched, so got to state $l$. \nSo ...\n$F[j]= \\text{the length of the longest prefix of } P \\text{that is a suffix of }P[1..j]$.\n\n![41c3a0c8.png](41c3a0c8-kl2ssw8h.png)\n\nThis takes a while, but there's actually a $O(m)$ algorithm to compute the same thing. That means that KMP is $\\Theta(n+m)$.\n\n---\n## Suffix trees\n\nSometimes you're looking for many patterns within some fixed text.\n\nThe idea is to preprocess $T$.\n\n$P$ is a substring of $T$ iff $P$ is a prefix of some suffix of $T$. (ok lol)\n\nThe idea is to store all suffixes of T in a trie.\n\nTo save space, we used a compressed trie, and we store suffixes implicitly via indices into $T$. So we store $i, j$, the indices of the suffixes of $T$.\nThis is called a **suffix tree**.\n\n![ec0fabeb.png](ec0fabeb-kl2ssw8i.png)\n\nThis becomes:\n\n![17c2483e.png](17c2483e-kl2ssw8g.png)\n\nAnd then compress:\n\n![cdc6f6ac.png](cdc6f6ac-kl2ssw8i.png)\n\nThis is the **suffix tree**.\n\nWe can build this tree in $\\Theta(n^2)$ by inserting each suffix.\n\nHowever, there's a way to build the tree in $\\Theta(n)$ time, but that's beyond the scope of this course.\n\n---\n\nNow for string matching. We assume we have a suffix treeof text $T$.\n\n![9b9652af.png](9b9652af-kl2ssw8i.png)\n\nBasically, once you hit a leaf in the above algorithm, use the indices stored there to do your final guess, final comparison.\n\n![3c1b50f0.png](3c1b50f0-kl2ssw8h.png)\n\n---\n## Conclusion\n\n![4cda70cf.png](4cda70cf-kl2ssw8h.png)","tags":[],"folderPathname":"/imported/CS240","data":{},"createdAt":"2020-07-15T19:07:15.751Z","updatedAt":"2020-07-16T14:48:32.148Z","trashed":true,"_rev":"KvsPJm023_C"}