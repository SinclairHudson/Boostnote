{"_id":"note:GGacp2_Le3d","title":"Week 08: Multicycle Datapath","content":"# Week 08: Multicycle Datapath\n\nThe key is to break the single cycle into 5 different parts, and have 5 clock cycles.\n5 shorter clock cyles, still 1 instruction.\nThe instructions remain the same.\n\nHere's the multicycle:\n\n![defc600a.png](defc600a-kl2ssw81.png)\n\nThese intermediate registers (blue), let us carry information across clock cycles.\n\nThe names are:\n1. IF: instruction fetch\n * compute and $PC=PC+4$ (could be modified later)\n * Read the instruction\n2. ID: instruction decode\n * compute control bits\n * Reading from register file\n3. EX: execute\n * Compute using the ALU\n * branch offset if you're a branch\n4. MEM: Memory\n * Idle\n * Dealing with memory (stur and ldur)\n * Updating PC if required.\n 5. WB: Write back\n * Write to register\n \n The clock cycle should be the maximum of any individual step cost. So 200ps. Memory read or write is the bottleneck.\n \n We also have an MCC Controller, which is an FSM, to make sure everything happens in order. First IF, then ID, etc. The MCC Controller also has control bits, like write bits for the intermediate register banks. It tells them when to write.\n \n At this point, a single instruction has **exclusive use of the data path**.\n \n ![23b6280d.png](23b6280d-kl2ssw80.png)\n \n ---\n ## Pipelining\n An actual unit.\nNow, we do parallel instruction computation. Big efficiency gains.\nHowever, it's not perfect. There's a chance we get collisions, called **hazards**. For example, we can't use X5 before we've modified it, if it's used in two consecutive instructions.\n\nThe same intermediate registers are in play, this time called \"Pipeline registers\".\n\nOne new instruction starts every clock cycle. The ideal is that we finish one instruction every clock cycle.\n\nMost of the time, PC = PC+4. But branch occurs later. So we'll see that right after branches we fetch instructions that we might not want to. We have to discard these instructions.\n\nWe actually don't have a Controller anymore, because the pipeline registers are written to every single cycle. The data relevant to the instruction is carried with the instruction through the pipeline.\n\nThere are sometimes conflicts in the register file. We can allow read and then writing in the same clock cycle. But we should **write and then read**, to avoid reading outdated info. We also need to modify the D-Flip-Flops to write on the rising edge of the clock cycle, while reads occur on the falling edge. This means that both can happen in one clock cycle.\n\nControl bits also get carried forward in the Pipeline Registers. They're computed in the ID stage, and they pass through to enable correct execution.\n\nThis specific pipelined datapath is called **Branch in the Mem Stage**:\n\n![04716598.png](04716598-kl2sswab.png)\n\n---\n\nCritically, CBZ updates the PC a little late, 3 other instructions have already been started. In this case, we just have to scrap those three instructions and start again, with the correct PC this time. This is just as good as waiting, and for most of the instructions parallel computation means faster throughput.\n\nIn this video, rosina also goes through an example of an ADD instruction. Nothing unintuitive.\n\n## Pipeline Hazards:\n3 kinds:\nStructural Hazard: with single instruction.data memory, instruction fetch cannot overalp with load/store\nThis isn't a problem for us, because our IM and DM are different.\n\n### Data Hazard Example: Result of one instruction is needed by needed by next instruction.\nFor example:\n```\nADD X1, X2, X3\nSUB X4, X1, X5\n```\n![934b416f.png](934b416f-kl2ssw81.png)\n\nWe can't go back in time! However, if we allow reading in the rising edge of the clock cycle, then we can write and read in a single clock cycle. This can be seen above, with the AND instruction.\n\nTo fix this, we delay the execution of dependent instructions by using **NOPs**. No operations. They do nothing, but add space between dependent instructions.\nSo our code becomes:\n```\nADD X1, X2, X3\nNOP\nNOP\nSUB X4, X1, X5\n```\nThe cost is one CC per NOP. The NOPs are added by the compiler, and they get their own line number.\n\nIs this the only solution?\n\n![883b6f14.png](883b6f14-kl2ssw81.png)\n\nRemember that the value put into X1 by the first add instruction is actually computed before it is written to the register... 2 clock cycles before, right after the ALU, the EX stage of the ADD intruction...\n\nSo the second solution is to forward the result right to the ALUs in the dependent instructions, before the value is stored in mem.\nThis is called **Data Forwarding**:\n\n![810f7e07.png](810f7e07-kl2ssw80.png)\n\nThe above diagram is not complete, just simplified.\n\n![d3d5c39e.png](d3d5c39e-kl2ssw81.png)\n\nThere's a detection phase, made by the forwarding unit. It looks at the Rn or Rm and the Rd, to see if there are any hazards.\nThe purple path shows how the new value of X5 can be plugged in to the ADD instruction.\n\nNever grab mid-cycle; always grab from stable memory.\n\n![7c9a042c.png](7c9a042c-kl2ssw80.png)\n\nA cleaner diagram ^.\n\nSo really, there are two steps:\n1. Check to see if there are hazards, using the values of Rm, Rd, Rn of multiple commands.\n2. Choose the correct values for ForwardA and ForwardB using the MUXes.\n\nDefault choice for ForwardA and ForwardB is 0, use the mux to just pass what we normally would.\nThere are some conditions to check for data hazards.\n\n![5e5f9f22.png](5e5f9f22-kl2ssw80.png)\n\n![f6eb8bef.png](f6eb8bef-kl2sswac.png)\n\n!!! danger LDUR\nLDUR is an exception. There's no stable value in the Rd of LDUR until the result is in the WB stage. So we actually have to place a NOP between LDUR and a dependent instruction. This is a compiler issue.\n\nThis is called a **load-use hazard**.\n![783b9219.png](783b9219-kl2ssw80.png)\n\nIf we have forwarding, we just need 1 NOP in between. Else, every data hazard needs 2 NOPS. Forwarding is clearly an improvement.\n!!!\n\n## Control Hazard Example: Conditional branch instruction may change sequence if instructions executed.\n\n\n\n","tags":[],"folderPathname":"/imported/CS251","data":{},"createdAt":"2020-06-30T22:35:33.551Z","updatedAt":"2020-08-14T17:45:55.093Z","trashed":true,"_rev":"gOB9VNkjVU3"}