{"_id":"note:LdNM8kundIH","title":"Problem 17: Abstraction over Containers","content":"## Problem 17: Abstraction over Containers\n\nRecall: map from Racket\n```\n(map f (list abc)) => (list (f a) (f b) (f c))\n```\nWe may want to do the same with vectors.\nLet's assume target has enough space to hold a much of source as we want to send.\n```cpp\ntemplate<typename T1, typename T2>\nvoid transform(const vector <T1> &source, vector<T2> &target, T2(*f)(T1)){\n  auto it = target.begin();\n  for(const auto &x:source){\n    *it = f(x);\n    ++it;\n  }\n}\n```\nBut, what if we only want part of the source?\nWhat if we want to send the source to the middle of target, and not the beginning?\n\nMore general: use iterators:\n\n```C++\ntemplate <typename T1, typename T2> void transform(vector<T1>::iterator start, \n    vector<T1>::iterator finish, vector <T2>::iterator target, T2 (*f)(T1)) {\n    while (start != finish) {\n        *target = f(*start);\n        ++start;\n        ++target;\n    }\n}\n```\n\nOk, but what if I want to transform a list? I'd like to reuse this function.\nWhat if I want to transform a list to a vector, or vice versa?\n\nMake the types stand for the iterators, not the container elements. But then how do we indicate the type for `f`?\n\n```C++\ntemplate<typename InIter, typename OutIter, typename Fn>\nvoid transform(InIter start, InIter finish, OutIter target, Fn f) {\n    while (start != finish) {\n        *target = f(*start);\n        ++start;\n        ++target;\n    }\n}\n```\n\nWorks over vector iterators, list iterators, or any kinds of iterators.\n\nInIter/OutIter can be any types that support `++`, `*`, `!=`, including ordinary pointers.\n\nC++ will instantiate a template function with any type that has the operations being used by the function.\n\n`Fn` can be any type that supports **function application**, including a lambda.\n","tags":[],"folderPathname":"/CS246E","data":{},"createdAt":"2019-10-22T15:10:09.261Z","updatedAt":"2019-12-05T17:11:18.659Z","trashed":false,"_rev":"JHDXieQl4Ga"}