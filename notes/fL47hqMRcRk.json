{"_id":"note:fL47hqMRcRk","title":"Problem 33 - I want a smaller vector class","content":"## Problem 33 - I want a smaller vector class\n\nCurrently, vector/vector_base have an allocator field.\nThe allocator field is stateless - has no fields. What is its size? It's not 0 - **C++ forbids it**. It doesn't make sense and screws up all the math. So **all sizes are >= 1**;\n\nPractically - compiler places a dummy char inside allocator. So having an allocator as a field makes the vector larger by a byte. One byte. It doesn't sound like much, but **alignment** might allocate 8 bytes or 4 bytes to **get the pointer field to land on an address divisible by 4 or 8**.\n\nTo save this space, C++ provides the **empty base optimization (EBO)**. Under EBO, an empty base class does not have to occupy space in an object.\n!!! note Newer versions\nThis is fixed in newer versions of C++. We don't have this problem in newer versions.\n!!!\n\nSo we can eliminate the space cost of an allocator by making it a base class. At the same time, we can make vector_base a base class of vector.\n\n```cpp\ntemplate<typename T, typename Alloc = allocator<T>>\nstruct vector_base : Alloc{\n  size_t n, cap;\n  T *v;\n  using Alloc::allocate; //Because Alloc is a template arg, we don't know what it looks like.\n  using Alloc::deallocate; //So if we want to use inherited members, we need using declarations to make them visible.\n  \n  //etc\n  \n  vector_base(size_t n):n{0}, cap{n}, v{allocate(n)}{}\n  ~vector_base(){deallocate(v,n);}\n};\n```\n\n```cpp\n//private inheritance, no is-a\ntemplate<typename T, typename Alloc=allocator<T>> class vector: vector_base<T,Alloc>{\n  using vector_base<T,Alloc>::n;\n  using vector_base<T, Alloc>::cap;\n  using vector_base<T, ALloc>::v; //same reason as above\n  using Alloc::allocate;\n  \n  //etc\n  \n  public:\n    // use n, cap, u instead of vb.n, vb.cap, vb.v\n}\n```\nPrivate inheritance is used because this class isn't a special allocator. \n\nuninitialized_copy, etc - need to call construct/ destroy\nsimplest - let them take allocator as param\n\n```cpp\ntemplate<typename T, typename Alloc>\nvoid uninitialized_fill(T *start, T*finish, const T&x, Alloc a){\n  ~~~~\n    a.construct(~~~~);\n    ~~~~~\n    a.destroy(~~~~~);\n  ~~~~~~~\n}\n```\n\nBut how can vector pass an allocator to these functions?\n\n```cpp\nuninitialized_fill(u, v+n, i, static_cast<Alloc &> (*this)); //cast yourself to base class reference.\n```\nBut this doesn't work, because the children of vector_base don't know it's an alloc!\n\nSo we have to use **protected inheritance** - my children can know my parent class but nobody else.\n\nSo above, we now have\n```\nstruct vector_base: protected Alloc{}\n```\n\n### Final words\n\nThe goal of this course is abstraction. C++ is the king of abstractions. Abstractions have tradeoffs, and it depends on your client. Hopefully now you know how to create amazing abstractions that are high level, but have extremely fine-grain control. What is the client going to do? It's hard to come up with a language that can get extreme efficiency but can also have a pleasant interface.","tags":[],"folderPathname":"/CS246E","data":{},"createdAt":"2019-12-03T15:47:16.847Z","updatedAt":"2019-12-03T16:20:01.160Z","trashed":false,"_rev":"Kd7_CbRUy7L"}