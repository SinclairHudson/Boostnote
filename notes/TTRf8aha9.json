{"title":"L4: Synchronization","content":"\n## OS of the day\nMCP - 1961, developed with Burroughs Small\n\nFirst OS to \n\n* be written entirely in a high level language\n* Supported multiple processors\n* Multi-tasking/threading\n* implement virtual memory\n* provided source to users; users submitted patches (open-source, but only for burroughs owners)\n\n:::danger trap frame: saves all the register values\n:::\n\n![](image-kk6yx06x.png)\n\n\ncontext switches are actually pretty expensive. 3 or 4 functions.\n\n\n# Synchronization\n\nThreads can actually communicate with each other.\n\nbut you have to be careful with shared global variables! Because two\n\n![](image-kk6zg1bv.png)\n\n![](image-kk6zgndm.png)\n\nThe result of `total` could be anything.\nThe issue is that `total++` happens in one assembly call. It is not, and it can be interupted half way though.\n\n![](image-kk6ziyig.png)\n\n![](image-kk6zl29d.png)\n\nIt's as if sub never ran!\n\n![](image-kk6zmuqx.png)\n\nIt's as if add never ran!\n\n\n:::danger Race condition\nWhen the order of execution depends on which thread executes first.\n\n:::\n\nCommon occurrences\n1. Programmer's fault\n2. ...\n3. ...\n\nCompiler doesn't always look for race conditions; it doesn't even know if you're using multiple threads.\n\nEnforcing Mutual Exclusion:\nwe need **LOCKS** on shared variables in critical sections.\n\nAnyone who has to access the shared variables has to wait.\n\n![](image-kk7059td.png)\n\n![](image-kk706e78.png)\nThis lock doesn't work, because of there's a **RACE CONDITION**!\nA thread can walk inside, you walk into the stall, but before you can lock it, you get distracted (switch), and someone walks into the stall, and then we're in an awkward spot.\n\n## Can we even do this in C?\nWe can, but it would be slow.\n\nSo we need to go lower, into assembly.\n\n![](image-kk70c8xz.png)\n\nThe key is that this is in hardware; it's **atomic**, a single assembly instruction, so it can't be interrupted.\n\n![](image-kk70dgz5.png)\n\n![](image-kk70fdt8.png)\n\n![](image-kk70jo9z.png)\n\n![](image-kk70oy4a.png)\n\n### Spinlocks in OS/161\n![](image-kk70qmxg.png)\n\n\n:::caution The issue with spinlocks:\n\nA thread could spend its entire schedule quantum asking if the lock is available\n:::\n\nWe only want to use spinlocks for the most basic operations, because they're **actively waiting** on other threads. Spinlocks are owned by the CPU, and when a spinlock is acquired, inturrupts are disabled.\n","tags":[],"folderPathname":"/CS350","data":{},"createdAt":"2021-01-20T20:08:55.268Z","updatedAt":"2021-01-21T15:45:11.604Z","trashed":false,"_id":"note:TTRf8aha9","_rev":"81-890a6696f94121a7af52851929ea5400"}