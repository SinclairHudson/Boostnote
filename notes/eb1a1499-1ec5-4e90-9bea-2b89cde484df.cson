createdAt: "2019-10-03T14:05:18.213Z"
updatedAt: "2019-12-05T01:51:20.517Z"
type: "MARKDOWN_NOTE"
folder: "13f1477d1dab07e879ca"
title: "Problem 11: Better Initialization"
tags: []
content: '''
  ## Problem 11: Better Initialization
  
  Long sequence of `push_back`s are clunky:
  
  Arrays: `int a[] = {1,2,3,4,5};` :)
  Vector: `vector v; v.push_back(1); v.push_back(2); ...` :(
  
  Let's fix that.
  ```cpp
  template <typename T> class vector{
    ...
    public:
    vector(); ...
    vector(size_t n, T i = T{}):n{n}, cap{n == 0?1:n}, theVector{new T [cap]}{
        for(size_t j=0; j<n;++j) theVector[j]=i;
      }
  }
  ```
  Now we can do:
  ```cpp
  vector <int> v; //empty
  vector <int> v{5}; // 0 0 0 0 0
  ```
  !!! note T{}
  The default constructor means 0 if T is a built-in type
  !!!
  
  ```cpp
  vector<int> v{3,5}; // 5 5 5 - conversion
  ```
  This is good, but can we get the _true_ array style initialization?
  Yes. Here's a lesson in trickery. :)
  
  ```cpp
  #include <initializer_list>
  template <typename T> class vector{
    ...
    public:
      vector():...
      vector(size_t, T i = T{}): ...
      vector(std::initializer_list<T> init):n{init.size()},cap{n == 0?1:n}, theVector{new T[cap]}{
        size_t i = 0;
        for(auto t:init) theVector[i++] = t;
      }
  }
  ```
  So, what this allows us to do now, is this:
  ```cpp
  vector<int> v{1,2,3,4,5,6}; // 1 2 3 4 5 6
  vector<int> r; //empty
  vector<int> v{5}; // uhhhh (5)
  vector<int> v{3,5}; // what do these make? (3, 5)
  //so the other ctor, the newer one, is being called.
  ```
  Precedence goes:
  1) default constructors
  2) initializer_list constructors
  3) other constructors
  
  So to get the other constructor to run, we need to use round bracket initialization.
  ```cpp
  vector <int> v(5); // 0 0 0 0 0
  vector <int> v(3,5); // 5 5 5
  ```
  
  !!! note Cost
  Items in an init list are stored in contiguous memory (begin/eng return ptrs). So we're basically using one array to build another, which means for a moment you have 2 copies of the array in memory. But you can't just use initializer_list as the data structure; they're meant to be immutable.
  * Do not try to modify their contents
  * Do not use them as standalone data structures.
  !!!
  
  By using an `initializer_list` is actually usually more efficient. Since we double the size whenever we reach that cap on a `push_back`, there's a lot of deallocation or reallocation when we use `initializer_list`. In general, if you know how large your vector will be, you can save reallocation cost by requesting the memory up front.
  
  ```cpp
  template<typename T> class vector{
    ...
    public:
      ...
      void reserve(size_t newCap){
        if (cap<newCap){
          T *newVec = new T[newCap];
          for(size_t i = 0; i<n;++i){
            new Vec[i]=theVector[i];
          }
          delete [] theVector;
          theVector = newVec;
          cap = newCap;
        }
      }
      ...
  }
  ```
  `reserve` just saves us a bunch of reallocations. We can ask for memory up front now.
  ```cpp
  vector<int>v;
  v.reserve(100);
  v.push_back(~~~); // can do 100 pushbacks without reallocating things.
  ```
'''
linesHighlighted: [
  40
  5
  7
]
isStarred: false
isTrashed: false
