{"_id":"note:_g7aHl3kx","title":"Problem 04: The Copier is Broken","content":"## Problem 04: The Copier is Broken\n\nConsider the following:\n```cpp\nvector v;\nv.push_back(100);\n...\nvector w = v; //this is allowed. It constructs w as a copy of v.\nw.itemAt(0); //will return 100\nv.itemAt(0) = 200;\nw.itemAt(0); //200\n```\nSo we have a **shallow copy**, they're sharing an array. You're in for a world of hurt Jimbo.\n![68c.png](https://i.kym-cdn.com/photos/images/original/001/443/076/68c.png)\nThe same two objects think they own their fields, a double delete when the destructor runs will crash your program.\n\nWhen we copy objects like this, it invokes a **copy constructor**.\n```cpp\nstruct vector{\n  vector(const vector &other){...} //copy ctor\n}\n```\nThe compiler supplies this copy ctor- it just copies all fields. This is called a **shallow Copy**.\nWe need a **deep copy**.\nSo we need to write our own copy constructor.\n\n---\n```cpp\nstruct Node{\n  int data;\n  Node *next;\n  ...\n  Node(const Node &other):data{other.data},\n    next{other.next? new Node{*other.next}:nullptr}{} //could be null\n}; //again, this is recursive.\n```\nOK. Problem solved. So now when we construct a copy, this will run and deep copy. \nConsider:\n\n```cpp\nvector v;\nvector w;\nw = v; //copy, but not a constrution\n      //copy assignment operator\n      //compiler-supplied - copies each field (shallow)\n```\nNow the object has already been constructed. so by doing `w=v;`, w's old heap allocated array is thrown away, **leaked**.\n\nSo we've gotta write an assignment operator.\n##### Deep copy assignment:\n!!! error Doesn't work\n```cpp\nstruct Node{\n  int data;\n  Node *next;\n  ...\n  Node &operator = (const Node &other){ //returns Node & so that a = b = c = d works\n    data = other.data;\n    delete next;\n    next = other.next? new Node{*other.next}:nullptr;\n    return *this; //commonplace syntax, always the case in copy assignment \n  }\n};\n```\nConsider \n```cpp\nNode n{...};\nn=n; \n```\nDestroys n's data and then tries to copy it.\n!!!\nWe've got to ensure that the operator works in the case of **self-assignment**. This is very niche but it's important\nInstead, we should do this:\n```cpp\nstruct Node{\n  int data;\n  Node *next;\n  ...\n  Node &operator = (const Node &other){ //returns Node & so that a = b = c = d works\n    if(this == &other){\n        return *this; //do nothing if it's a self assignment.\n    }\n    data = other.data;\n    delete next;\n    next = other.next? new Node{*other.next}:nullptr;\n    return *this; //commonplace syntax, always the case\n  }\n};\n```\n##### Alternative: copy and swap idom\n```cpp\n#incldue <utility>\nstruct Node{\n  ...\n  void swap(Node &other){ //exchange my data with another's data\n    using std::swap;\n    swap(data, other.data);\n    swap(next, other.next);\n\n  }\n  \n  Node &operator = (const Node &other){\n    Node tmp = other;\n    swap(tmp);\n    return *this;\n  }\n}\n```\nThis seems too simple, but it works.\nConstruct a copy, swap copy data with mine. `tmp` now has my old data, which dies with the scope because `tmp` is stack allocated.\n!!! note Copy Constructor\nYou must take the copy constructor \"other\" parameter by **reference**, because otherwise you'd have to copy it befor bringing it into the copy function... Recursive definition.\n!!!\n","tags":[],"folderPathname":"/imported/CS246E","data":{},"createdAt":"2019-09-19T14:30:05.287Z","updatedAt":"2019-12-04T22:17:16.275Z","trashed":true,"_rev":"2PRdf3VFmK"}