{"title":"L7: volatile and Deadlocks","content":"## L07: \n\nDon't worry about memory leaks, don't use `thread_join`.\n\n![](image-kko3tvx8.png)\n\nProducers and Consumers problem.\n\nWe need a safe way to fall asleep in the critical section.\n\n![](image-kko43cwn.png)\n\n![](image-kko44hy4.png)\n\nRemember the two other race conditions?\n\nthe \n1. compiler\n2. CPU\n\n\nThe compiler tries to minimize the running time of the code that it converts into assembly. For example, it replaces local constants by evaluating them and then just replacing them in the code. Compiler optimizations. Loop unrolling does a similar thing.\n\nOr if you rearrage loads and stores to prevent hazards, then you could move in and out of the critical section.\n\nmodern CPUs also rearranges the loads and stores.\nMemory models describe how thread access to memory in shared regions behave.\n\n`volatile`\n\n![](image-kkqwo5kq.png)\n\n![](image-kko4zv6r.png)\n\nVolatile doesn't prevent a race condition. It disables an optimization that can cause problems. Declare shared variables with `volatile`.\n\n![](image-kko54byo.png)\n\n\n### Deadlock\n\nA state in which all threads can't make progress\n\n![](image-kkqwwo33.png)\n\nthey're both sleeping on each other. **Deadlock**.\nBe careful! In this case, the two locks should probably be the same thing.\n\n![](image-kkqwz4l7.png)\n\nBut No Hold and Wait requires a new function: `try_acquire(lock)`\n\n```c\ntry_aquire(lock){\n    spin_acq(lk->spin)\n        if(lk->held)\n            \n```\n![](image-kkqx301b.png)\nBasically, if you fail to get the second, then release the first, yield, and then try again.\n\nYou're allowed to wait if you own nothing.\n\n### Resource Ordering:\n\nGive each of our resources a unique ID. And then always acquire the resources in a strictly increasing order. We don't get deadlock, there's no Catch 22.\n\n![](image-kkqx5akv.png)\n\nBut the thing with resource ordering, is that you would have to sort the resources before you go, if you have an array of resources. So then it get's really slow.\n\nThere's also the Banker's Algorithm in CS 343.\n\n","tags":[],"folderPathname":"/CS350","data":{},"createdAt":"2021-02-02T14:34:46.824Z","updatedAt":"2021-02-04T14:32:45.514Z","trashed":false,"_id":"note:nnI40754J","_rev":"58-b7cdc2e6a140f1b4bd5b4ae1f18ef2ee"}