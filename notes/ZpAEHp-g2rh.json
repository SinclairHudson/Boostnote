{"_id":"note:ZpAEHp-g2rh","title":"M4: Dictionaries and Balanced Search Trees","content":"## M4: Dictionaries and Balanced Search Trees\n\n!!! note Dictionary\nA collection of items, each of which has a _key_ and a _value_. Key-value pairs. Keys are usually unique.\n\nWe have:\n`search(k)`\n`insert(k, v)`\n`delete(k)`\n\nThere are many examples of dictionaries. \n!!!\n\nWe assume that a dictionary has $n$ KVPs, each KVP has constant space, and Keys can be compared in constant time.\n\nWe can implement as an unordered array or linked list:\n`search(k)` is $\\Theta(n)$.\n`insert(k, v)` is $\\Theta(1)$.\n`delete(k)` is $\\Theta(n)$ (need search.)\n\nIn an ordered array:\n\n`search(k)` is $\\Theta(\\log n)$. (uses a search).\n`insert(k, v)` is $\\Theta(n)$.\n`delete(k)` is $\\Theta(n)$\n\n---\n\nLet's review BSTs. Every node holds a key and a value, and we're more concerned with the key. \n\nOrdering is the big thing: Every key in the left branch is left than the root key, and every key in the right branch is greater than the root key.\n\n`BST-search(k)`. We start at the root, then go left if our desired key is less than the root, right is our desired key is greater than the root. If they're equal, we've found the key. If we hit an empty branch, it doesn't exist in the tree.\n\n`BST-insert(k, v)` is a very similar algorithm. However, once we get to an empty tree, put in a new node with our KVP.\n\n`BST-delete` first we search for the node. If it's a leaf just delete it. If there's just one child branch, then delete our current node and the branch takes its place. If there are two children, we have a more complicated operation:\n\nWe **swap the key with a successor or predecessor** and then delete. Basically, you look for the successor, which is the node with the next greatest value. the Successor can take the place of what you want to delete; it will not violate the invariant.\nAlso, the successor is a leaf. So, you swap the two, and then delete the leaf. EZ. The predecessor is the next smallest key in the BST, and it will also be a leaf. It's a pretty crafty algorithm. \n\nAll the above three algs are $\\Theta(h)$, where $h$ is the height. So the question is; how big could $h$ be?\n\nWell, the worst BST is a linear one; the height is $n-1$. Worst case complexity for the above algs is $\\Theta(n)$. The best case is when the tree is perfectly balanced; $\\Theta(\\log n)$. The average case is also $\\Theta(log n)$.\n\nBut can we improve that worst case? Yes, see below.\n\n---\n\n### AVL trees\n\nIt's a more strict BST, that enforces balance. This guarantees a height of $O(\\log n)$.\nWe will also have to modify insert/delete so that they maintain our additional invariants.\n\n!!! caution The invariant\nThe hieghts of the left subtree $L$ and the right subtree $R$ differ by at most 1.\n$$height(R) - height(L) \\in {-1, 0, 1}$$\n!!!\nIn the above equation, $-1$ means _left-heavy_.\n$0$ means balanced,\n$1$ means _right-heavy_.\nRemember, the height of an empty tree is $-1$. \nWe need to store the height of each subtree in the root node. Otherwise, we've have a lot of extra computations.\n\nExample of AVL trees.\n\n![f3d5c4a6.png](f3d5c4a6-kl2ssw7u.png)\n\n---\n\n!!! quote An AVL tree of $n$ nodes has $\\Theta(\\log n)$ height.\nThis implies that all the AVL operations `insert, search, delete` are $\\Theta(n)$ in the **worst case**.\n\nThe proof is to find that $h \\in O(\\log n)$. We find the minimum number of nodes in a height $h$ AVL tree.\n!!!\n\nMeta pro-tip: [The On-Line Encyclopedia of Integer Sequences® (OEIS®)](https://oeis.org/)\n\n---\n\nNow let's talk about the operations in AVL trees.\n`AVL-insert(T, k, v)`:\nThe general idea is to insert as you normally would, then go back up, checking that the tree is still balanced.\n\nSo, as you go up, add 1 to the height (because you inserted), and then check that the difference in heights between the right and left branches is still acceptable. You move up until you hit a problem, then you apply a **rotation** to fix the problem. Then continue moving up in the same fashion, still checking for problems. However, when performing a rotation, you counteract the +1 height of the higher nodes.\n\nNote: we assume that our nodes have parent links.\n\n![32d3a736.png](32d3a736-kl2ssw7u.png)\n\nThere's a video example here.\n\n---\n\n### Rotations\n\nRotations are part of AVL fixes\n\n![08ac0944.png](08ac0944-kl2ssw7u.png)\n\n---\n\n![8cae0712.png](8cae0712-kl2ssw7u.png)\n\nIn the above diagram, we try to move towards the center tree.\n\n---\n\naaaand then I discovered the coursenotes lol.","tags":[],"folderPathname":"/imported/CS240","data":{},"createdAt":"2020-06-14T23:38:21.052Z","updatedAt":"2020-06-15T01:22:00.354Z","trashed":true,"_rev":"CdrxP4Xgssl"}