createdAt: "2019-10-10T14:30:30.716Z"
updatedAt: "2019-10-31T20:14:26.944Z"
type: "MARKDOWN_NOTE"
folder: "13f1477d1dab07e879ca"
title: "Problem 15: Is vector exception safe?"
tags: []
content: '''
  ## Problem 15: Is vector exception safe?
  
  Consider:
  ```cpp
  template <typename T> class vector{
    size_t n, cap;
    T *theVector;
    public: //assume n > 0
      vector(size_t n, const T&x):n{n},cap{n},
      theVEctor{static_cast<T*> operator new(n *sizeof(T))}{
        for size_t i = 0; i < n; ++i){
          new (theVector +i) T(x); //copy ctor - what if it throws?
        }
        ...
  }
  ```
  If that copy constructor throws, then we have a partially constructed vector, the destrcutor will not run. But then, all the T elements and the array will not be deleted. That's a broken invariant, since it doesn't contain n valid T objects.
  
  !!! note `new` throwing
  If operator `new` throws, nothing has been allocated, so there's actually no problem. Strong guarantee.
  !!!
  
  Le fix:
  ```cpp
  template<typename T> vector<T>::vector(size_t n , const T&x):n{n}, cap{n},theVector{~~~~~~~~~~~~~~~~~~~~}{
    size_t progress = 0;
    try{
      for(progress = 0; progress<n; ++progress){
        new (theVector + progress) T(x);
      }
    }   // catch ALL. catch anything
    catch(...){
      for(size_t i=progress; i>0; --i) theVector[i-1].~T();
      operator delete(theVector);
      //we need to re-throw
      throw;
    }
  }
  ```
  Now we need to abstract the filling part into its own function:
  ```cpp
  template<typename T> void uninitialized_fill(T *start, T *finish, const T&x){
    T *p;
    try{
      for (p=start; p!=finish; ++p){
        new (p) T(x);
      }
    }
    catch(...){
      for(T *q=p; q!=start; --q) (q-1)->~T();
      throw;
    }
  } 
  ```
  ```cpp
  template<typename T>vector<T>::vectorrr(size_t n, const T &x):n{n},cap{n}, theVector{static_cast<T*>(operator new (n *sizeof(T)))}{
    try{
      uninitialized_fill(theVector, theVector+n, x); //strong guarantee
    }
    catch(...){
      operator delete(theVector);
      throw;
    }
  }
  ```
  We can clean this up by doing RAII on the array:
  ```cpp
  template<typename T> struct vector_base{
    T *v;
    size_t n, cap;
    vector_base(size_t n):v{static_cast<T*> (operator new(n*sizeof(T)))},n{n},cap{n}{}
    ~vector_base(){operator delete(v);}
  };
  ```
  ```cpp
  template<typename T> class vector{
    vector_base<T> vb; //cleaned up implicitly when vector is destroyed.
    public:
      vector(size_t n, const T&x): vb{n}{
        uninitialized_fill(vb.v,vb.v+vb.cap,x);
        vb.n = vb.cap;
      }
      ~vector(){destroy_elements();}
      ...
  }
  ```
  There's no try block, but it is exception safe.
  
  But that was just one constructor... vector has many.
  ```cpp
  template<typename T> vector<T>::vector(const vector &other):vb{other.size}{ //similar to uninitialized_fill (MIDTERM)
    uninitialized_copy(other.begin(), other.end(), vb.v);
    vb.n=vb.cap; 
  }
  ```
  
  Assignment - copy and swap are exception safe, as long as swap is no-throw.
  
  push_back:
  ```cpp
  void push_back(const T&x){
    increaseCap(); //and what if increaseCap fails?
    new(vb.v+vb.n) T(x); //don't increment n before you know the construction has succeeded.
    //and if T(x) throws, we still have the same vector. so it's safe.
    ++vb.n;
  }
  ```
  ```cpp
  void increaseCap(){
    if(vb.n==vb.vb.vap){
      vector_base<T> vb2{2*vb.cap};
      uninitialized_copy(vb.v,vb.v+vb.n,vb2.v); //strong guarantee
      destroy_elements(); //nothrow
      std::swap(vb,vb2); //swap is nothrow on ints and pointers
    }
  }
  ```
  And the only try blocks we've done are in uninitialized_fill and uninitialized_copy. 
  
  ##### This works, but we have an efficiency issue
  
  With copying from the old array to the new one. We should be moving instead of copying.
  But if we're moving, then we don't have the old array to fall back on.
  Moving ruins the old array, so if an  exception is thrown during moving, our old vector is not intact. We can only move if we are sure that the move operation is **no-throw**.
  ```cpp
  void increaseCap(){
    if(vb.n==vb.vb.vap){
      vector_base<T> vb2{2*vb.cap};
      uninitialized_copy_or_move(vb.v,vb.v+vb.n,vb2.v); //strong guarantee
      destroy_elements(); //nothrow
      std::swap(vb,vb2); //swap is nothrow on ints and pointers
    }
  }
  ```
  ```cpp
  template <typenmae T> void uninitialized_copy_or_move(T *start, T *finish, T *target){
    T *p;
    try{
      for(p=start;p != finish, ++p, ++target){
        new(target) T (std::move_if_noexcept(p)); //produces std::move(x) if x has a non-throwing move ctor
        //produces x otherwise.
      }
    }
    catch(...){
     //omitted.
    }
  }
  ```
  You have to tell the compilter that T's move ctor is non-throwing. 
  tag it like this: `C (C &&other) noexcept;`
  Don't lie with noexcept!
  
  In general: moves & swaps should be non-throwing. Declare them so, which will allow more optimized code to run. Any function that you are sure will never have to throw or propagate an exception, you should declare `noexcept`.
  
  Q: Is `std::swap` noexcept?
  ```cpp
  template<typename T> void swap(T &a, T &b){
    T c(std::move(a));
    a = std::move(b);
    b = std::move(c);
  }
  ```
  A: Only if T has nothrow move constructor or move assignment. So how do we specify this?
  
  ```cpp
  template<typename T> void swap(T &a, T &b)
  noexcept(std::is_nothrow_move_constructable<T>::value && //oh lawd
          std::is_nothrow_move_assignable<T>::value){ //just a boolean condition  
    T c(std::move(a));
    a = std::move(b);
    b = std::move(c);
  }
  ```
  
'''
linesHighlighted: []
isStarred: false
isTrashed: false
