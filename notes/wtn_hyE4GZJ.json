{"_id":"note:wtn_hyE4GZJ","title":"A Big Unit on Object-Oriented Design","content":"## A Big Unit on Object-Oriented Design\n\nSystem modelling - UML - Unified Modelling Language\nMakes it easy to communicate what the design of your program is.\n![uml_2.png?width=600&name=uml_2.png](https://www.gliffy.com/hs-fs/hubfs/uml_2.png?width=600&name=uml_2.png)\n\n* Italic Class = abstract\n* Italic Method = virtual\n*  \\- private\n*  \\# protected\n*  \\+ public\n\n@startuml\nBook <|-- Text\nBook <|-- Comic\nMotor <--* Car\n\n@enduml\n\nHere, a Car owns a Motor. The motor is part of the car. does not have an independent existence.\nTo copy a car, you would deep copy the motor.\nBut consider the following:\n@startuml\n\nDuck --o Pond\n\n@enduml\nA pond **has a** duck, also known as an aggregation. Copying and destroying the pond does not imply that you copy and destroy the Ducks. Typical implementation is by a pointer field.\n\n!!! note Ownership\nWho (which class) has ownership, and who is umtimately responsible for it. It's a big part of the course, and central to object oriented design in C++. Every resource should be owned by an object that will release it - RAII. A unique-ptr owns the memory it points to.\n* A unique pointer **owns** the memory it points to.\n* A raw pointer should be regarded as not owning the memory it points to.\n\nSo you can say that raw pointers should never be deleted. If it's unique, it'll be deleted for you. If it's a raw pointer, it's someone else's job to delete it.\n!!! \n\nIf you need to point at the same object with several pointers, one pointer should own it and be a `unique_ptr`. The rest should be raw pointers. When we move a `unique_ptr`, we're really transferring ownership. If you need **true** shared ownership, ~~~~~.\n\n### Measures of Design Quality\n\nCoupling and Cohesion. How much stuff to you keep in a module?\n!!! hint Coupling\nHow strongly different modules depend on each other. How independent are they?\n* **low**: function calls with params/results of basic types\n* **low-med**: function calls with array/struct params.\n* **med**: modules affect each other's control flow\n* **high**: modules access each other's implementation. They're friends.\n\nPerfect coupling is that everything is the same class.\n!!!\n\n!!! hint Cohesion\nHow closely are element of a module related to each other?\n* **low**: arbitrary grouping (eg `<utility>`)\n* **low-med**: some common theme, otherwise unrelated. Might share some base code. (eg `<algorithm>`)\n* **med**: elements manipulate state over the lifetime of an object. (eg open/read/close files)\n* **med-high**: elements pass data to each other\n* **high**: elements cooperate to perform exactly one task. They can't function without each other. UwU <3\n\nPerfect Cohesion means everything is in different modules but everything communicates.\n!!!\n\nIt's hard to change a module in high coupling without changing other modules. Harder to reuse individual modules. Low cohesion is poorly organized, hard to understand, hard to maintain. Hard to reuse small pieces. \n\n#### We want high cohesion, low coupling.\n\n","tags":[],"folderPathname":"/CS246E","data":{},"createdAt":"2019-10-31T15:08:21.205Z","updatedAt":"2019-11-05T16:02:57.525Z","trashed":false,"_rev":"A06L6gMTWWf"}