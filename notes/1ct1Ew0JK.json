{"_id":"note:1ct1Ew0JK","title":"Problem 24: Abstraction over Iterators","content":"## Problem 24: Abstraction over Iterators\n\nI want to jump ahead **n** steps in my iterator.\n\n```cpp\ntemplate <typename Iter> Iter advance(Iter it, size_t n){\n  for(size_t i = 0; i < n; ++i) ++it;\n  return it;\n}\n```\nEz clap. But it's slow... it runs in $O(n)$.\n\n#### Can we jump ahead quickly?\nIt depends on what you're iterating over. For vectors, yes of course. The iterators are just pointers. For lists, you have to take n steps of length 1.\n\n#### Can we go backwards?\nFor vectors, yes.\nfor singly linked lists? no.\n\nAll iterators support !=. *, ++. Some iterators support other operations.\n\n`list::iterator` - called a **forward iterator**: it can only go one step forward.\n\n`vector::iterator` - called a **random access iterator**: can go anywhere. Arbitrary pointer arithmetic.\n\nHow ca we write advance to use `+=` for random access iterators and loop for forward iterators?\n\nSince we have different kinds of iterators, let's create a type hierarchy:\n```cpp\nstruct input_iterator_tag{};\nstruct forward_iterator_tag: public input_iterator_tag{};\nstruct bidirectional_iterator_tag: public forward_iterator_tag{};\nstruct random_access_iterator_tag: public bidirectional_iterator_tag{};\n```\n\nTo associate each iterator class with a tag - could use inheritance:\n\n```cpp\nclass List{\n~~~\npublic:\n  class iterator: public forward_iterator_tag{~~~~};\n}\n```\n\nHowever, it makes it hard to ask what kind of iterator we have. We can't dynamic cast with no vtables.\nDoesn't work for iterators that aren't classes.\nInstead, make the tage a member:\n```cpp\nclass List{\n~~~\npublic:\n  class iterator{\n  ~~~\n  public:\n  using iterator_category = forward_iterator_tag; //this will be the convention\n  // every iterator class will define a type member called iterator_category.\n  ~~~\n  };\n};\n```\nBut this also doesn't work for iterators that aren't classes. But we aren't done yet. We can make a template that associates every iterator type with its category:\n```cpp\ntemplate<typenmae It> struct iterator_traits{\n  typedef typename It::iterator_category iterator_category; //why typename?\n}\n```\n#### Why typename?\nIt's needed so that C++ knows that It::iterator_category is a type. Remember, the compiler knows nothing about `It`.\n\nConsider:\n```cpp\ntemplate<typename T> void f(){\n  T::something a; //only makes sense if T::something is a type.\n}\n```\n\nAlso consider:\n```cpp\ntemplate<typename T> void f(){\n  T::something *x; //is that a pointer declaration, or a multiplication? You can't tell unless you know that T::something is a type. C++ assumes value instead of type. \n}\n```\nSo it has to be:\n```cpp\ntemplate<typename T> void f(){\n  typename T::something *x;\n}\n```\n\nYou need to say typename whenever you refer to a member type of a template parameter. \n\n---\nBack to iterator_traits.\n\n`iterator_traits<List<T>::iterator>::iterator_category` will give forward_iterator_tag.\n\nProvide a specialized version for ptrs.\n\n```cpp\ntemplate<typename T> struct iterator_traits<T*>{\n  typedef random_access_iterator_tag iterator_category;\n};`\n```\nfor any iterator type T, `iterator_traits<T>::iterator_category` resolves to the tag struct for T. (including if T is a pointer).\n\nWhat do we do with it?\n\nWant:\n```cpp\ntemplate<typename It> It advance(It it, int n){\n  if(typeid(iterator_traits<It>::iterator_category)= typeid(random_access_iterator_tag)){\n    return it+=n;\n  }\n  else if(~~~){\n  ~~~\n  }\n}\n\n```\nIf the iterator is not random access, and therefore doesn't have a += operator, `it +=n` won't compile. Even though it will never be used. Moreover, the choice of which impl to use is being made at run-time, when the right choice is known at compile-time.\n\nWe need a compile-time decision: **overloading**.\n\nFor any iterator type T, `iterator_traits<T>::iterator_category` resolves to the tag struct for T (incl if T is a ptr)\n```cpp\ntemplate<typename Iter> Iter doAdvance(Iter it, int n, random_access_iterator_tag){\n  return it += n;\n}\ntemplate<typename Iter> Iter doAdvance(Iter it, int n, bidirectional_iterator_tag){\nif(n>o){\n  for(int i= 0; i < n; ++i){\n    ++it\n    }\n}\nelse if(n< 0) {for(int i = 0; i < -n; ++i) --it;}\nreturn it;\n}\n\ntemplate<typename Iter> Iter doAdvance(Iter it, int n, forward_iterator_tag){\n  if(n >= 0){\n    for(int i = 0; i < n; ++i) ++i;\n    return it;\n  }\n  throw SomeError{};\n}\n```\nFinally, create a wrapper function to select the right overload:\n\n```cpp\ntemplate <typename Iter> Iter advance (Iter it, int n){\n  return doAdvance(it, n, iterator_traits<Iter>::iterator_category{});\n}\n```\nNow, the compiler will select the fast doAdvance for random access iterators, the slow doAdvance for bidirectionalad iterators, and the throwing doAdvacnce for forward iterators.\nThis is all decided at compile-time, so there's no cost to runtime efficiency.\nUsing template instantiations to perform compile-time computation is what's called **template meta-programming**.\n\nC++ templates form a **functional language** that operates at the level of types. They're **Turing Complete**. Bruh.\nExpress conditions via overloading, repetition via recursive template instantiation.\n```cpp\ntemplate <int N> struct Fact{\n  static const int value = N * Fact<N-1>::value;\n};\n\ntemplate <> struct Fact<0>{\n  static const int value = 1;\n};\n\nint x = Fact<5>::value; //120 - evaluated at compile-time.\n```\n\nBut for compile-time computation of values, C++ 11/14 offer a more straightforward facility.\n\n```cpp\nconstexpr int fact(int n){ //constexpr functions mean\n  if(n==0) return 1;      //evaluate this at compile-time if n is a compile-time constant\n  return n*fact(n-1);     //else evaluate at run-time.\n}\n```\n\nA constexpr function must be something that actually can be evaluated at compile-time.\n* can't be virtual, of course\n* can't mutate non-local variables.","tags":[],"folderPathname":"/CS246E","data":{},"createdAt":"2019-11-19T15:31:06.153Z","updatedAt":"2019-11-20T17:59:53.436Z","trashed":false,"_rev":"jXrP5K_YXW"}