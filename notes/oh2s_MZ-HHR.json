{"_id":"note:oh2s_MZ-HHR","title":"Problem 07: Tampering","content":"## Problem 07: Tampering\n```cpp\nvector v;\nv.cap = 100; //sets the cap without allocating memory\n\nv.pushback(1); //will likely crash. The user has interfered with our datatype.\n```\nInterfering with ADTs\n1) **Forgery** - creating an object without using a constructor function. Not possible since we wrote ctors\n2) **Tampering** - accessing the internals without using a provided interface function.\n\n!!! hint Invariant\nA statement that will always be true about an abstraction.\n!!!\nStacks provide the invariant that the last item pushed is the first item popped.\nWe need to secure the invariant for our ADTs, specifically for vectors:\n\nVectors rely on the invariant that elements 0...cap-1 denote valid locations.\n\nAnd we can't guarantee this if the user interferes with our internals.\n\nFix: Encapsulation\n!!! hint Encapsulation\nWe will seal objects into \"black boxes\" to protect their fields.\n!!!\n\n#### vector.h\n```cpp\nnamespace CS246E{\n  struct vector{\n    private: //visible only within the vector class\n      int *theVector;\n      size_t n, cap;\n    public: //visible to all (default)\n      vector();\n      size_t size() const;\n      void pushback(int n);\n  }\n}\n```\n\n#### vector.cc\n```cpp\n  #include \"vector.h\"\n  namespace{ //this no longer works, because it doesn't have access to v's internals.\n    void increaseCap(vector &v){...}\n  }\n```\n\nTry again:\n#### vector.h\n```cpp\nnamespace CS246E{\n  struct vector{\n    private: //visible only within the vector class\n      int *theVector;\n      size_t n, cap;\n    public: //visible to all (default)\n      vector();\n      size_t size() const;\n      void pushback(int n);\n    private:\n      void increaseCap(); //now it's a private method\n  }\n}\n```\n\n#### vector.cc\n```cpp\n  #include \"vector.h\"\n  namespace CS246E{ //no longer static (anonymous namespace)\n    ...\n    void vector::increaseCap(){...}\n    ...\n  }\n```\n\nStructs provide public default access.\nIt's better if the default access is private...\nWe can't change struct, because C is still here.\n`class` is exactly like struct, but **private by default**.\nThis is more *mysterious*, more classy. Classy people never overshare.\n\n#### vector.h\n```cpp\nclass vector{\n  int *theVector;\n  size_t n, cap;\n  public:\n    vector();\n    ...\n  private: //whitespace is merely convention\n    void increaseCap();\n}\n```\n---\nA similar problem exists with linked lists.\n```cpp\nNode n{3,nullptr}; //on the stack\nNode m{4,&n}; //this will oof, trying to delete something on the stack\n```\nThere used to be an invariant - next is nullptr or was allocated by new.\n\n### 9/26/2019\nNeed to make sure `&n` in the above code is nullptr, or allocated by new.\nAbstract further! We need to go deeper. We will encapulate node inside a \"wrapper class\".\n\n```cpp\nclass list{\n  struct Node{ //nested class, useful for scoping\n  //nobody can even say the word node outside of this class.\n    int data;\n    Node *next;\n    //methods\n  };\n  Node *theList;\n  list():theList{nullptr}{}\n  ~list(){delete theList;}\n  size_t size() const;\n  \n  void push_front(int n){theList=new Node{n,theList};}\n  void pop_front(){\n    if(theList){\n      Node *tmp=theList;\n      theList=theList->next;\n      tmp->next=nullptr;\n      delete tmp;\n    }\n  }\n  const int &operator[](size_t i)const{\n    Node *cur = theList;\n    for(size_t j = 0; j < i, ++j, cur = cur->next);\n    return cur->data;\n  }\n  int &operator[](size_t i){...}\n}\n```\nAnd see because the nodes are private, the client cannot access any pointers. Invariant is secured.\n\n\n\n","tags":[],"folderPathname":"/imported/CS246E","data":{},"createdAt":"2019-09-25T16:48:20.057Z","updatedAt":"2019-12-05T01:18:18.851Z","trashed":true,"_rev":"Q9WzNHQqaCs"}