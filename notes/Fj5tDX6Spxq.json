{"_id":"note:Fj5tDX6Spxq","title":"Problem 31: I want total control over vectors + lists","content":"## Problem 31: I want total control over vectors + lists\n\nHow can we incorporate custom allocation into our containers?\n\nBut there's an issue: we may want different allocators with different kinds of vectors.\n\nSolution: pass in the allocator as a template argument.\n\nSince most users won't write allocators, we will need a default value.\n```cpp\ntemplate<typename T, typename Alloc=allocator<T>> class vector{\n~~~\n}\ntemplate <typename T> class allocator{ //default - uses standard operator new/delete\n  public:\n    using value_type = T;\n    using pointer = T*;\n    using reference = T&;\n    using const_pointer = const T*;\n    using const_reference = const T&;\n    using size_type = size_t;\n    using difference_type = ptrdiff_t;\n    //bruh\n    \n    allocator() noexcept{}\n    allocator(const allocator &) noexcept{};\n    ~allocator() noexcept{}\n    pointer address(reference x) const noexcept{return &x;}\n    const_pointer address(const_reference x) const noexcept{return &x;}\n    pointer allocate(size_type n){\n      return ::operator new(n*sizeof(T));\n    }\n    void deallocate(pointer p, size_type n){ ::operator delete(p);}\n    template<typename U, typename ...Args>\n    void construct(U *p, Args && ... args){\n      ::new (p) U(forward<Args>(args)...);\n    }\n    template <typename U> void destroy(U *p){p->~U();}\n};\n```\nIf you want to write your own allocator for use with standard containers, it must use this interface.\n\nTo adapt vector to use this:\n* vector has a field Alloc alloc;\n* replace calls to operator new with alloc.allocate\n* replace calls to placement new with alloc.construct\n* replace calls to destructor (explicitly) with alloc.destroy\n* replace calls to operator delete with alloc.deallocate\n* everwhere vector takes an address, call alloc.address\n\n\nCan we do the same with list? Not exactly.\n```cpp\nteplate<typename T, typename Alloc = allocator<T>> class list{~~~};\n```\n\nCorrect so far, but Alloc will never be used to allocate memory in list.\n\nWhy not? lists are node-based - means you dont actually want to  allocate T objects; you want to allocate __nodes__. (which contain T objects and pointers)\n\nBut Alloc allocates T objects.\n\nHow do we get an allocator for nodes?\nEvery conforming allocator has a member template called rebind that gives the allocator type for another type.\n\n```cpp\ntemplate <typename T> class allocator{\n~~~\npublic:\n  ~~~\n  template <typename U> struct rebind{\n    using other=allocator<u>;\n  };\n  ~~~~\n};\n```\n\nWithin list - to create an allocator for nodes as a field of list:\n```cpp\nAlloc::rebind<Node>::other alloc;\n```\n\nThen use as in vector.","tags":[],"folderPathname":"/CS246E","data":{},"createdAt":"2019-11-28T15:17:14.910Z","updatedAt":"2019-11-28T15:46:32.224Z","trashed":false,"_rev":"LiPoJtls-sU"}