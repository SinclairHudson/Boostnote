{"_id":"note:UsDGbOYw_hB","title":"Week 07: Single Cycle Conditional Branch","content":"# Week 07: Single Cycle Conditional Branch\n## Conditional Branches\n![73c83160.png](73c83160-kl2t950v.png)\n\nThese are relative 2's complement addresses.\n\nRemember, $PC = PC + 4(Address)$. With the conditional branch.\nNote: Rt = Rd. For some reason we just have Rt in this example. \n\nTo accomplish the $\\times 4$? We **bit-shift left 2** positions! We don't actually lose any info when bit shifting, because remember this 64 bit number was sign extended from 19 bits.\nSo PC gets ALU'd with a bit shift left to get the new PC. \nWe use the \"Pass b\" operation in the main ALU to pass the Rt without modifying it. So the result is B, or Rt. And at the end of the ALU, we have the **Zero bit**. So we and it with the \"Branch\" control bit. If they're both true, then we branch, because it's CBZ.\n\nNote that we'll actually read from a random register for register 1. But we're passing B, so it doesn't matter.\n\n\n![b0ff60db.png](b0ff60db-kl2t950v.png)\n\nYou have to set the memory bits to 0 to avoid a seg fault, even though we don't use memory. It still executes.\n\n---\n\n## Control units in the data path\nControl Unit takes the opcode, and sets all the control bits. It also controls the ALUOp line, so it inadvertently controls the ALU Control.\n!!! note ALU Control info\nALUOp bits: \n01 means \"pass b\"\n00 is add,\n11 is subtract,\n10 mean's it's an R-format, so follow the function bits.\n\nNote that these are the **control bits**, not the actual input to the ALU.\n\n![1a5f0d0d.png](1a5f0d0d-kl2t950v.png)\n!!!\n!!! danger Not testable\nInternal Control unit looks like this:\n![03f2f147.png](03f2f147-kl2t950u.png)\n!!!\n\n\n---\n\n## Timing\nInstruction memory reads take 200 picoseconds\nRegister File takes 100 picoseconds per read or write.\nMain ALU take 200 picoseconds\nData memory takes 200 picoseconds.\n\nWith the above info:\nRformat takes: $200+100+200+100 = 600ps$\nLDUR takes $200+100+200+200+100 = 800ps$ (slowest)\nCBZ takes $200+100+200 = 500ps$\nSTUR takes $200 + 100 + 200 + 200 = 700ps$\n\nNotice how we didn't give a timing for the ALUs at the top of the diagram. These ALUs happen in parallel to our other calculations, and they're **never actually the bottleneck**. So, we don't need to consider them.\n\nNow, let's assume the Control Unit takes $10ps$. In this case, for R format, we need to wait that 10ps before we read from registers. So we add the 10ps.\n\nOur clock cycle time has to be set to 800ps to accommodate the slowest operation, LDUR. Floating point instructions actually take longer, so this will change later.\n\n---\n\n### MOdifying the single cycle data path\nFor CBNZ and B instructions.\n\n## B Instruction\n\n![c4d3761f.png](c4d3761f-kl2t950v.png)\n\nFor B, we can add a new control bit, B. B is 1 when we have the branch instruction. We can OR  the B signal with the AND of the Branch Control bit and the Zero ALU. This means that if B=1.\n\nThis unconditional branch takes $200+200 = 400ps$\n\n---\n\nThere's a section here on modifications, but it's so easy. Just intuitive.","tags":[],"folderPathname":"/CS251","data":{},"createdAt":"2020-06-27T13:50:34.468Z","updatedAt":"2020-08-14T17:45:48.366Z","trashed":false,"_rev":"F9LuJGMSZf-"}