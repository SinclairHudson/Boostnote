{"_id":"note:3BAWP2sD5qq","title":"5 Principles of Object Oriented Design. (SOLID)","content":"## 5 Principles of Object Oriented Design. (SOLID)\n\n### S - Single Responsibility Principle\nA class should have only one reason to change. A class should do one thing, not several. Any change to the program specification requires a change to the program. If changes to $\\geq 2$ different parts of the specification cause changes to the same class, SRP is violated.\n#### example : Don't let your main classes print things.\n\n```cpp\nclass ChessBoard{\n  ~~~~\n  cout << \"Your move punk\";\n  ~~~~\n}\n```\nThis may seem innocent, but it inhibits code reuse. Is it managing the board, or is it playing the game? What if we want a french version? What if it communicates over different streams? Then we have to change `ChessBoard`, which doesn't seem right. Requires major changes to the class, instead of reuse.\nThis is a violation of SRP. Changes to any of:\n* game rules\n* strategy\n* interface\n* etc\n\nWill need a change to `ChessBoard`. Split these responsibilities up.\n* One module resonsible for communication (not `main`! can't reuse `main`)\n* One module for a communications - let it do the talking.\n\nOn the other hand, specifications that are unlikely to change may not need their own class. Avoid needless complexity.\n\n### O - Open-Closed Principle\nClasses, modules, and functions should be open for extension and closed for modification. Changes to a program's behaviour should happen by writing new code, and not changing old code.\n\n@startuml\nCarpenter *--> Handsaw\n@enduml\n\nWhat if the carpenter buys a Table Saw? This design is not open for extension. We must change the code. We'll do some abstraction of course. The carpenter should work with an abstract saw.\n\n@startuml\nabstract class Saw\nCarpenter *--> Saw\nHandsaw --|> Saw\nTableSaw --|> Saw\n@enduml\n\nAlso note:\n```cpp\nint countHeavy(const vector<Book *> &v){\n  int count = 0;\n  for(auto &p:v){\n    if (p->isHeavy()) ++count;\n  }\n  return count;\n}\n```\nNo changes needed if new Books are invented.\nBut you can't really be 100% closed. Some changes may require source modifications. But plan for the most likely changes and make your code closed with respect to those changes.\n\n### L - Liskov Substitution Principle\nSimply put: public inheritance must indicate and **is - a** relationship. If B is a subclass of A, then we should be abloe to use an object b of type B in any context that requires a type A **without affecting the correctness of the program**. C++'s inheritance rules already allow us to use subclass objects in terms of superclass objects. The program should \"not be able to tell\" if it's using a superclass or a subclass object; it shouldn't matter. \nMore formally, if an invariant I is true for class A, then it must be true for class B. If an invariant I is true for A::f, and B::f overrides A::f, then I must hold for B::f.\n\nIf A::f has precondition P and postcondition Q, then B::f must have a precondition $P' <= P$ and postcondition $Q' => Q$. So you can get from P to Q through A::f or B::f. If A::f and B::f behave differently, the difference in behaviour must fall within what is allowed by the program's correctness specification.\n\nExamples:\n1) Contravariance Problem - arises any time you write a binary operator, ie a method with an \"other\" parameter of the same type as *this.\n\n\n@startuml\nabstract class Shape\nCircle --|> Shape\nSquare --|> Shape\n@enduml\n\n```cpp\nclass Shape{\n  public:\n    virtual bool operator==(const Shape &other) const = 0;\n};\n\nclass Circle: public Shape{\n  public:\n    bool operator==(const Shape &other)const override;\n}\n```\nHaving `const Circle &other` in the override would not be an override. Also, it would break LSP. A Circle is a Shape, so it should be compared with any other shape. This is a compiler error because it is at the type level.\n\nThe fix:\n```cpp\n#include<typeinfo>\n~~~~~~\nbool Circle::operator==(const Shape &other) const{\n  if(typeid(other) != typeid(Circle)) return false;\n  const Circle &other = static_cast<const Circle &>(other); //safe\n  ~~~~~\n}\n```\n```cpp\ndynamic_cast<const Circle&>(other) //is other a Circle, or a subclass of Circle?\ntypeid(other) == typeid(Circle) // is other precisely a Circle?\n//^-- returns an object of type type_info\n```\n2) Is a square a rectangle?\n\nA square has all the properties of a rectangle.\n```cpp\nclass Rectangle{\n  int length, width;\n  public:\n    Rectangle (int length, int width): ~~~~~~~~\n    int getLength() const; virtual void setLength(int length){~~~~~~}\n    int getWidth() const; virtual void setWidth(int width){~~~~~~~}\n    int area() const{return length*width;}\n    ~~~~~~\n};\n\nclass Square: public Rectangle{\n  public:\n    Square(int side):Rectangle{side,side}{}\n    void setLength(int l) override{\n      Rectangle::setLength(l);\n      Rectangle::setWidth(l);\n    }\n    void setWidth(int w)override{~~~~~} //similar\n};\n\nint f(Rectangle &r){\n  r.setLength(10);\n  r.setWidth(20);\n  return r.area(); //should be 200\n}\n\nSquare s{1};\nf(s); //400\n```\n\nSo really, rectangles have a property that squares do not. You can change their length and width independently. So this violates LSP. On the other hand, an immutable Square could substitute for an immutable rectangle.\n\n@startuml\nabstract class Shape\nabstract class RightAngledQuadrilateral\nRectangle --|> RightAngledQuadrilateral\nSquare --|> RightAngledQuadrilateral\nRightAngledQuadrilateral --|> Shape\n@enduml\n\nThis is good because it preserves invariants of Rectangles, and squares.\n\n### Constraining what subclasses can do:\n\nLet's say we're writing a video game:\n```cpp\nclass Turtle{\n  public:\n    virtual void draw = 0;\n};\nclass RedTurtle: public Turtle{\n  public:\n    void draw() override{\n      drawHead();\n      drawRedShell();\n      drawFeet();\n    }\n};\nclass RedTurtle: public Turtle{\n  public:\n    void draw() override{\n      drawHead();\n      drawGreenShell();\n      drawFeet();\n    }\n};\n```\nThe code for RedTurtle and GreenTurtle is pretty similar. There's a lot of code duplication.  How can we ensure that overrides will always do these things?\n\n```cpp\nclass Turtle{\npublic:\n  public void draw(){\n    drawHead();\n    drawShell();\n    drawFeet();\n  }\nprivate:\n  doid drawHead();\n  virtual void drawShell()=0;\n  void drawFeet();\n};\n\n\nclass RedTurtle: public Turtle{\n  void drawShell() override;\n} //GreenTurtle is similar\n```\n\nSubclasses cannot control the steps of drawing a turtle, nor the drawing of head and feet. They can only control the drawing of the shell.\nThis is called the **Template Method Pattern**. A design template. But why is drawShell() private? Just because a subclass can't call it doesn't mean it can't override it.\n\n### Extension: NVI (Non-Virtual Interface) idiom.\n* public virtual methods are simultaneously\n  * part of a class' interface - pre/post conditions, class invariants\n  * \"hooks\" for customization by subclasses\n    * overriding code could be anything\n\nThese two points are at odds with each other\n!!! note NVI\nall virtual methods should be private (or at least protected).\nThe converse is that all public methods should be non-virtual.\n(except the destructor lul)\n!!!\n\n```cpp\nclass DigitalMedia{\n  public:\n    virtual void play() = 0; //Not NVI oof\n}\n```\n```cpp\nclass DigitalMedia{\n  public:\n    void play(){\n      doPlay(); //can add before/after code. You could check copyright here, or update a total play count.\n    };\n  private:\n    virtual void doPlay() = 0;\n}\n```\n\nGeneralizes Template Method Pattern - put every virtual function inside a template method.\n## I - Interface Segregation Principle\nMany small interfaces are better than one large interface.\nIf a class has many functionalities, each client of the class should see only the functionality it needs.\n\n---\n\nLet's say we're writing a video game.\n```cpp\nclass Enemy{\n  public:\n    virtual void draw(); //needed by the interface\n    virtual void strike(); //needed by the game logic\n};\n\n\nclass UI{\nvector <Enemy *> v;\n\n};\nclass Battlefield{\n  vector <Enemy *> v;\n};\n\n```\n\nIf we  need to change the drawing interface, Battlefield must also recompile, for no reason. The class enemy did change, but not in a way that affects Battlefield.\nIf we need to change the combat interface, UI must recompile. Creates needless coupling between UI and Battlefield.\n\nOne solution: multiple inheritance.\n```cpp\nclass Draw{\n  public:\n    virtual void draw() = 0;\n};\nclass Combat{\n  public:\n    virtual void strike() = 0;\n};\n\nclass Enemy: public Draw, public Combat{};\n\nclass UI{\n  vector <Draw *> v;\n};\n\nclass Battlefield{\n  vector <Combat *> v;\n}\n```\n\nThis is called the **Adapter Pattern**. The general use of Adapter: when a class provides an interface different from the one you need.\n\n@startuml\nclass NeededInterface{\n  g()\n}\nclass ProvidedClass{\n  f()\n}\nClass Adapter{\n  g()\n}\n\nAdapter --|> NeededInterface\nAdapter --|> ProvidedClass\n\n@enduml\nWhere Adapter::g() can call f().\n\nThe inheritence could be private, depends on whether you want the adapter to still support the old interface.\n\n---\n\n### Detour: issues with Multiple Interitance\n\n@startuml\nclass A1{\na()\n}\nclass A2{\na()\n}\n\nB --|> A2\nB --|> A1\n\n@enduml\n\nSo now B has 2 `a()` methods. YOu could call these by A1::a() and A2::a()\n\n@startuml\nclass A{\na()\n}\nB --|> A\nC --|> A\n\nD --|> B\nD --|> C\n\n@enduml\nNow D has 2 `a()` methods, and they're different.\n```cpp\nclass D: public B, public C{\n  void f(){~~~~~~~~~ a() ~~~~~~~~} //ambiguous. Use B::a or C::a\n};\n\nD d;\nd.a(); //use d.B::a() or d.C::a()\n```\n\nOr maybe tere should be only one A base, and therefore only one `a()`.\n```cpp\nclass B: virtual public A {~~~~}; //virtual inheritance\nclass C: virtual public A {~~~~};\nd.a() //no longer ambiguous\n```\n\nBut how will a class like D be laid out in memory? Well that's implementation specific.\n\n|vptr        |\n| :------------ |\n|A fields      |\n| B fields      |\n| C fields |\n| D fields   |\n\nThis memory model doesn't work because it doesn't look like a C object.\n\nA C object looks like this:\n|vptr        |\n| :------------ |\n|A fields      |\n| C fields |\n\nBut what does g++ actually do?\n\n|vptr        |\n| :------------ |\n| B fields      |\n|vptr|\n| C fields      |\n| D fields |\n|vptr|\n| A fields   |\n\nThe distance from a class to the base class part is not constant. The distance to your superclass is not always the same, and it depends on the runtime type of the object.\n\nSolution: location of base class stored in the vtable. The diagram doesn't simultaneously look like A, B, C, D, but slices of it do.\n\nSo **pointer assignment among A, B, C, D may change the address stored in a pointer**. That's weird.\n\n```cpp\nD * d = ~~~~~~;\nA * a = d; //changes the address downwards to the A part.\n```\nStatic_cast, dynamic_cast under Multiple Inheritance will also adjust the value of the pointer. reinterpret_cast will not.  \n\n## D - Dependency Inversion Principle\n\nHigh level modules should not depend on low level modules. Both should depend on abstractions. Abstract classes should never depend on concrete classes.\n\nTraditional top-down design:\n@startuml\nHighLevelModule --|> LowLevelModule\nWordCount --|> KeyboardReader\n@enduml\n\nDependency inversion:\n\n@startuml\nHighLevelModule --|> LowLevelAbstraction\nLowLevelModule --|> LowLevelAbstraction\n\nWordCount --|> InputInterface\nKeyboardReader --|> InputInterface\nFileReader --|> InputInterface\n@enduml\n\n##### example:\n\n@startuml\nclass Bell{\n  notify()\n}\nTimer *--> Bell\n\n@enduml\nWhat if we want the timer to trigger other events?\n@startuml\nclass Light{\n  notify()\n}\nclass Bell{\n  notify()\n}\nabstract class Responder{\n  notify()\n}\nTimer *--> Responder\nBell --|> Responder\nLight --|> Responder\n\n@enduml\nMaybe we want a dynamic set of responders\n@startuml\nclass Timer{\n  register(Responder)\n  unregister(Responder)\n}\nabstract class Responder{\n  notify()\n}\nTimer *--> Responder\nResponder *--> Timer\nBell --|> Responder\nLight --|> Responder\n\n@enduml\nBut now, Responder depends on a concrete class, which isn't allowed. But we can apply Dependency Inversion again.\n\n@startuml\nabstract class Source{\n  register(Responder)\n  unregister(Responder)\n}\nabstract class Responder{\n  notify()\n}\nclass Timer{\n  getTime()\n}\nTimer --|> Source\nSource *--> Responder\nLight --|> Responder\nBell --|> Responder\nBell *--> Timer\nLight *--> Timer\n@enduml\n\nIf Light/Bell's behaviour depends on the timer, they may only need to depend on the concrete timer for a getTime method.\n\nThis example above is known as the **Observer Pattern**.\n@startuml\n\nabstract class Subject{\n  notifyObservers()\n  attach(Observer)\n  detach(Observer)\n}\nabstract class Observer{\n  notify()\n}\nSubject *--> Observer\n\nclass ConcreteObserver{\n  notify()\n}\nclass ConcreteSubject{\n  getState()\n}\nConcreteSubject --|> Subject\nConcreteObserver *--> ConcreteSubject\nConcreteObserver --|> Observer\n\n@enduml\n\nSequence of calls:\n1) Subject's state Changes\n2) Subject::notifyObservers - calls each observer's notify (could be called by Subject or an outsider controller)\n3) Each observer calls ConcreteSubject::getState to query the state and reacts accordingly.\n\nSee horse race example in code repository.  \n\n## More Design Patterns\n\n### Factory Method Pattern\nI need to create an object, but I don't know which one I want. My preferences may vary.\nAlso called the virtual constructor pattern.\nIt's really the strategy pattern applied to object construction.\n\n@startuml\nabstract class Enemy\nTurtle --|> Enemy\nBullet --|> Enemy\n@enduml\nIn the easier levels I want more turtles, in the harder ones I want more bullets.\n@startuml\nabstract class Level\nEasy --|> Level\nHard --|> Level\n@enduml\n\n```cpp\nclass Level{\npublic:\nvirtual Enemy * getEnemy() = 0; //should really be a unique pointer.\n}\n\nclass Easy: public Level{\npublic:\n  Enemy * getEnemy() override{\n  //mostly turtles\n  }\n};\n\nclass Hard: public Level{\npublic:\n  Enemy *getEnemy() override{\n    //mostly bullets.\n  } \n};\n\n~~~~~~\n  Level *l = new ~~~~~~~~;\n  Enemy *e = l->getEnemy();\n```\n---\n### Decorator Pattern\nWhen you want to add or remove functionality from objects at runtime.\n\nEg. add menus/scrollbars to basic windows - either or both.\nI want the ability to have all these optional features without having to write a class for every combination.\n\n@startuml\nabstract class Component{\n  operation()\n}\nclass ConcreteComponent{ \n  operation()\n}\nConcreteComponent --|> Component\nabstract class Decorator{\n  \n}\nDecorator --|> Component\nclass ConcreteDecoratorA{\n  operation()\n}\nclass ConcreteDecoratorB{\n  operation()\n}\n\nConcreteDecoratorA --|> Decorator\nConcreteDecoratorB --|> Decorator\nDecorator *--> Component : underlying, less decorated object\n@enduml\n\nEvery decorator IS a Component and HAS a Component\nWindowWithScrollbar is a kind of Window and has a ptr to the underlying plain window\nWindowWithScrollbarAndMenu is a window and has a ptr to Window w/Scrollbar, which has a ptr to Window.\n\n```cpp\nWindowInterface *w = new WindowWithMenu{ new WindowWithScrollBar{new Window}};\n```\nThis would look like a **linked list** in memory.\nThere's an example of this in the code repo - pizza.\n\n### Visitor Pattern\nFor implementing **Double Dispatch**.\nmethod chosen based on the runtime type of 2 objects, rather than just one.\n\n@startuml\n\nabstract class Enemy\n\nTurtle --|> Enemy\nBullet --|> Enemy\n\nabstract class Weapon\n\nStick --|> Weapon\nRock --|> Weapon\n@enduml\n\nSo now the attack depends on the type of weapon and the type of the enemy. But that's not how virtual methods work! Virtual methods in C++ are dispatched on the types of receiver objects, and not method parameters. There is now way to specify two receiver objects.\n\nThe visitor pattern combines overriding with overloading to do a two-stage dispatch.\n```cpp\nclass Enemy{\n  virtual void beStruckBy(weapon &w) = 0;\n};\n\nclass Turtle: public Enemy{\n  void beStruckBy(weapon &w) override{\n    w.strike(*this);\n  }\n};\nclass Bullet: publicEnemy{\n  void beStruckBy(Weapon &w) override{\n    w.strike(*this); //the type of *this is different from above.\n  }\n}\n\nclass weapon{\npublic:\n  virtual void strike(Turtle &t) = 0;\n  virtual void strike(Bullet &b) = 0; //these are overloads\n}\n\nclass Stick: public Weapon{\npublic:\n  void strike(Turtle &t) override{\n  //when you strike a turtle with a stick.\n  }\n  void strike(Bullet &b) override{\n  //when you strike a turtle with a stick.\n  }\n};\n\n~~~~\n\nEnemy *e = new Bullet{~~~~~};\nWeapon *w = new Rock{~~~~};\ne->beStruckBy(*w); //What happens?\n```\n1) Bullet::beStruck runs (virtual method dispatch)\n2) calls Weapon::strike(Bullet &) (*this is a Bullet, known at compile time, overload resolution)\n3) virt method resolves to Rock::strike(Bullet &) //ayyyyyyy\n\nVisitor can also be used to add functionality to a class hierarchy without adding new virtual methods.\n\n#### Adding a visitor to the Book hierarchy:\n\n```cpp\nclass Book{\npublic:\n  virtual void accept(BookVisitor &v){v.visit (*this);}\n};\nclass Text: public Book{\npublic:\n  void accept (BookBisitor &v) override {v.visit (*this);}\n};\n~~~~~~\n\nclass BookVisitor{\npublic:\n  virtual void visit(Book &b) = 0;\n  virtual void visit(Text &t) = 0;\n  virtual void visit(comic &c) = 0;\n}\n\nstruct Catalogue: public Visitor{\n  map<string, int> theCat;\n  void visit(Book &b) override{\n    ++theCat[b.getAuthor()];\n  }\n  void visit(Text &b) override{\n    ++theCat[b.getTopic()];\n  }\n  void visit(Comic &b) override{\n    ++theCat[b.getHero()];\n  }\n}\n```\n!!! error Compiler error\nWe've got a circular include dependencies issue.\nbook.h, BookVisitor.h include each other.\ninclude guard prevents multiple inclusion.\nwhichever one ends up first will refer to things not yet defined.\n!!!\n\nKnow when the include is actually needed.\nNeedless #includes create artificial compilation dependencies and slow down compilation.\nSometimes, a forward declaration is good enough.\n\nConsider:\n#### A.h\n```cpp\nclass A{...};\n```\nAnd then:\n```cpp\nclass B{\n  A a;\n};\n```\n```cpp\nclass C{\n  A *a;\n};\n```\n```cpp\nclass D: public A{\n  ~~~\n};\n```\n```cpp\nclass E{\n  A f(a);\n};\n```\n```cpp\nclass F{\n  A f(A a){a.someMethod();}\n};\n```\n```cpp\nclass G{\n  t<A> x;\n};\n```\nIn order to know how big a B object is, we need to know how big A is. D objects also need this info. C just has a pointer, which doesn't need to know size. So we can just forward it.\nF needs to know a.someMethod, so we need an include. E does not require an include, just a forward. For G, it depends on how we use the template. It will collapse to one of the other cases.\n\nB, C, F need an include.\nC, E just need a forward declare.\nG depends. \n\nA forward declare just looks like `class A;`.\nNote that F only needs an include because method f's impl is present + uses a method of A. This is a good reason to keep implementation in .cc files.\n\nLet's look at the difference between B and C. B needs an include, C does not. So we could technically change B to C to get out of an include cycle.\n\nMore generally:\n```cpp\nclass B{\n  A1 a1;\n  A2 a2; //these require includes\n  A3 a3;\n}\n```\nOr, \n#### b.h\n```cpp\nclass BImpl; //forward declare only.  \nclass B{\n  unique_ptr<BImpl> pImpl; //pointer to implementation\n}\n```\n\n#### bimpl.h\n```cpp\nstruct BImpl{\n  A1 a1;\n  A2 a2;\n  A3 a3;\n};\n```\n\n#### b.cc\nmethods reference pImpl->a1, pImpl->a2 ...\n\nb.h no longer compilation dependent on a1.h, a2.h ...\n\ncalled the **pimpl idiom**.\n\nAnother advantage of pimpl: pointer have non-throwing swap.\nWe can provide the strong guarantee on a B method by copying the implementation into a new BImpl structure, heap allocated, method modifies the copy. If anything throws, discard the new structure (easy and automatic with unique_ptr). If all succeeds, swap Impl structs (nothrow). Previous impl automatically destroyed by unique_ptr.\n\n```cpp\nclass B{\n  unique_ptr<BImpl> pImpl;\n  ~~~~~\n  void f(){\n    auto temp = make_unique<BImpl>(*pImpl);\n    temp->doSomething();\n    temp->doSomethingElse();\n    std::swap(pImpl,temp); //no throw\n  } //strong guarantee\n};\n```","tags":[],"folderPathname":"/CS246E","data":{},"createdAt":"2019-11-05T16:02:58.568Z","updatedAt":"2020-05-31T14:54:30.695Z","trashed":false,"_rev":"fKYa1dCOdjd"}