createdAt: "2019-10-27T19:54:05.986Z"
updatedAt: "2019-12-04T22:06:27.617Z"
type: "MARKDOWN_NOTE"
folder: "13f1477d1dab07e879ca"
title: "Problem 03: Linear Collections and Memory Management"
tags: []
content: '''
  ## Problem 03: Linear Collections and Memory Management
  
  #### Arrays:
  
  ```cpp
  int a[10]; //array of 10 ints on the stack
  int *p = new int[10]; //array of 10 ints on the heap
  
  delete[] p; //to delete an array
  ```
  Use `delete` any time you use `new`.
  Use `delete[]` any time you use `new...[...]`.
  
  And what if we want to expand our array?
  **There is no realloc in C++ for new/delete.**
  
  So we're going to use absraction and data structures.
  #### vector.h
  ```cpp
  namespace CS246E{
    struct vector{
      int *theVector;
      size_t size, cap;
    };
    
    const size_t startSize = 1;
    vector makeVector();
    
    size_t size(const vector &v);
    
    int &itemAt(const vector &v, size_t i); //accessor, return a reference
    
    void push_back(vector &v, int n);
    void pop_back(vector &v);
    void dispose(vector &v)
  }
  ```
  #### vector.cc
  ```cpp
  #include "vector.h"
  
  namespace { //an unnamed namespace makes the functions private
  //you can't call these methods outside the namespace
  //this prevents tampering
    void increaseCap(CS246E::vector &v){
      if(v.size==v.cap){ //if we're full
        int *newVec = new int[2*v.cap]; //create a new array that's twice as big.
        for(size_t i = 0; i < v.cap; ++i){
          newVec[i]=v.theVector[i]; //copy all elements over
        }
        delete[] v.theVector;
        v.theVector = newVec;
        v.cap *=2; //double cap to reflect new max
      }
    }
  } //end of unnamed namespace
  
  int &CS246E::itemAt(const vector &v, size_t i){
    return v.theVector[i];
  }
  void CS246E::push_back(vector &v, int n){
    increaseCap(v);
    v.theVector[v.size++] = n;
  }
  void CS246E::pop_back(vecotr &v){
    if(v.size > 0){
      --v.size;
    }
  }
  void dispose(vector &v){
    delete[] v.theVector;
  }
  
  //implementations of methods we left unimplemented in vector.h.
  CS246E:vector CS246E::makeVector(){
    CS246E::vector v{new int[startsize],0,startSize};
    return v;
  }
  ```
  
  #### main.cc
  ```cpp
  #include "vector.h"
  using CS246E::vector; //vector equivalent to CS246E::vector
  
  int main(){
    vector v = CS246E::make_vector();
    push_back(v,1);
    push_back(v,10);
    push_back(v,100);
    
    itemAt(v, 0) = 2; //fine, we can mutate because we're dealing with references.
  }
  ```
  Notice how we can just use `push_back` in main and not `CS26E::push_back`. Why is that?
  
  !!! note Argument Dependent Lookup (ADL)
  If the type of a function f's argument belongs to a namespace n then C++ will search the namespace n for f, as well as the current scope. It's just a small little shortcut. Also called Koenig Lookup.
  !!!
  
  Since `v` belongs to CS246E namespace, C++ will search CS246E for `push_back`.
  
  ---
  What if we forget to call make_vector when we want to make a vector? We get an uninitialized vector.
  What if we forget to call dispose? we leak memory. It would be handy to have `dispose(v)` called automatically when v goes out of scope.
  
  ### Introduction to classes
  Here we are. Object Oriented Programming, finally.
  * **classes** are like structs with functions associated with them.
  * **objects** are instances of a class.
    * **instance variables** are the fields of a class.
  * **methods** are functions inside the class, associated with that class.
    * **destructors** are functions that delete/clean up the struct and free associated memory.
    * **constructors** are functions that create objects from classes, allocating memory and setting values.
    * **accessor methods** are functions that just return fields from the class.
    * **mutator methods** are functions that mutate the object in some way, potentially re-allocating memory.
  
  Let's do an example:
  ```cpp
  class Student{ //class
    int assns, mt, final; //instance variables
    
    float grade(){ //accessor method
      return assns*0.4+mt*0.2+final*0.4;
    }
    
    Student(inst a, int m, int f){ //constructor method
      assns = a;
      mt = m;
      final = f;
    }
  }
  
  int main(){
    Student bob{60,70,80}; //bob is an object, constructor called
    Student BOB = Student{100,70,80}; //equivalent
    Student * alice = new Student{90,90,100}; //alice is on the heap!
    Student bob; //default constructor, crashes 
    
  }
  ```
  
  It should be noted that there's a default constructor and destructor for each class. They can be overwritten by any constructor, so as soon as you write a constructor you can't use the default. Default constructors initialize all instance variables to default values. If the instance variables are objects, then they are constructed with default constructors. A default destructor deletes all the instance variables in a **shallow fashion**.
  
  !!! attention `this`
  Formally, methods differ from functions because methods take an implicit parameter called `this`. `this` is a pointer to the object itself. When we say `assns` in `grade()`, it's equivalent to `this->assns`.
  !!!
  
  ### Object creation Sequence:
  1) Space is allocated for the instance variables
  2) Superclass constructor runs (see problem 18)
  3) Fields are constructed in declaration order
  4) Constructor body runs
  
  So then the instance variable (field) initialization **actually happens twice**. Once in 3, and then again in 4 when the constructor body runs.
  
  This is innefficient, so of course there's a fix
  
  ### Member Initialization List (MIL)
  
  MIL must be used for fields that are constants, like
  * constants
  * references
  * objects without default constructors
  
  ```cpp
  class Student{
     int assns, mt, final;
     String name; //object
     Student(string name, int assns, int mt, int final){
      this->name = name;
      ... //etc
     } //this constructor is flawed. The name is initialized as the empty string first, and then
      //in the body it's reassigned. Use MIL instead
    
    Student(string name, int assns, int mt, int final):assns{assns},mt{mt},final{final},name{name}{}
    //so this consructor is equivalent to the one above, but MIL is part of part 3 of object creation.
    //part 4, the body of the constructor, is empty.
  }
  ```
  
  ---
  
  Watch out for single argument constructors. They can create implicit conversions.
  
  ```cpp
  Node n{4}; //OK
  Node n = 4; //OK ish. int is implicitly converted into a node.
  void f(Node n);
  f(4); //again fine, but 4 is implicitly converted into a node. You probably don't want this
  ```
  
  To prevent implicit conversions with single-argument constructors, use the keyword `explicit`.
  
  ```cpp
  struct Node{
  explicit Node(~~~~~~~);   {~~~~}
  };
  ```
  And now there's no implicit conversion; explicit nodes only.
  
  ## Object Destruction
  
  Objects must be destructed as well.
  
  A method called the destructor (dtor) runs automatically. There is a built-in destructor, calls dtors on all fields that are objects.
  
  ### Object Destruction sequence
  
  1) dtor body runs
  2) The fields are destructed (dtors are called on fields that are objects) in reverse declaration order. 
  3) Superclass destructor runs (problem 18)
  4) Space is deallocated
  
  Consider the Node structure.
  ```cpp
  Struct Node{
    int data;
    Node *next;
  };
  ```
  The dtor actually does nothing; neither field is an object.
  ```cpp
  Node *n=new Node{3, new Node{4, new Node {5, nullptr}}};
  delete n; //only deletes the first node, so we're in trouble
  ```
  ### Writing our own dtor:
  ```cpp
  struct Node{
    ...
    ~Node(){delete next;} //on delete, delete the next reference
  };
  delete n; //now frees the entire list
  ```
  
  Also consider:
  
  ```cpp
  {
  ...
  // n is on the stack
  Node n {1, new Node {2, new Node {3, nullptr}}};
  } //scope of n ends
  ```
  
  But the nodes with `new` in front of them are on the heap. However, thanks to our new, custom dtor, the whole linked list is freed. This process is actually recursive. Our dtor is a recursive function.
  
  !!! note Key Concept
  A ctor _always_ runs when objects are created.
  A dtor is _always_ run when they are destroyed.
  !!!
  
  ---
  
  Back to the vector example - let's turn it into a class:
  #### vector.h
  ```cpp
    namespace CS246E{
      struct vector{
        int *theVector;
        size_t n, cap;
        vector();
        size_t size();
        inst &itemAt(int i);
        void push_back(int n);
        void pop_back();
        ~vector();
      };
    }
  ```
  
  #### vector.cc
  
  ```cpp
  #include "vector.h"
  namespace{ //static
    void increaseCap(SC246E::vector &v){...}
  }
  CS246E::vector::vector():theVector{new int[1]}, n{0}, cap{1}{}
  size_t CS246E::vector::size(){return n;};
  ...
  CS246E::vector::~vector(){delete []theVector;}
  ```
  
  #### main.cc
  
  ```cpp
  using CS246E::vector;
  int main(){
    vector v; //ctor is automatically called here
    v.push_back(10);
    v.push_back(10);
    v.push_back(100);
    
    v.itemAt(0)=2;
  } //no call to dispose -dtor cleans v up automatically.
  ```
  
  
  Now it's really simple. The client cannot forget to deallocate or allocate vectors properly, and it still works as intended. This is the power of object oriented programming.
  
  ---
  
  This is the same as when files were being opened and closed. We didn't have to call fopen and fclose explicitly because they were abstracted away in ctor and dtor of the class.
'''
linesHighlighted: [
  9
]
isStarred: false
isTrashed: false
