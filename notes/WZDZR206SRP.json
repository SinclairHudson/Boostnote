{"_id":"note:WZDZR206SRP","title":"Problem 18 - Heterogeneous Data","content":"## Problem 18 - Heterogeneous Data\n\nI want a mixture of types in my vector, like Python.\nA template can't really express this.\n\na vector of templates doesn't work, because templates are compile-time entities.\n\nAvailable in C:\n* unions: `union Media{Song s; Movie m};`\n  * not super safe, you have to remember what's in your object. There is only one.\n* void * - point to anything.\n  * void *nowPlaying\n\nThese are not type-safe.\n\nItems in a heterogeneous collection will usually have something in common, right?\nThey might provide a common interface.\n\nCan be viewed as different \"kinds\" of a more general \"thing\".\nSo have a vector of things or a field of type thing.\n\n```C++\nclass Book {    // Superclass or Base class\n        string title, author;\n        int length;\n    public:\n        Book(string title, string author, int length):\n            title{title},\n            author{author},\n            length{length} {}\n\n        bool isHeavy() const { return length > 100; }\n\n        string getTitle() const { return title; }\n\n        // etc.\n};\n```\n```C++\nBOOK\n+--------+\n| Title  |\n+--------+\n| Author |\n+--------+\n| Length |\n+--------+\n```\nSome books are special though\n```C++\nclass Text: public Book {   // Subclass or Derived class\n        string topic;   // No need to mention title, etc. because it comes from book\n    public:\n        Text(string title, string author, int length, string topic): \n            Book{title, author, length}, \n            topic{topic} {}\n\n        bool isHeavy() const { return length > 500; }\n        string getTopic() const { return topic; }\n};\n```\n```C++\nTEXT\n+--------+\n| Title  |\n+--------+\n| Author |\n+--------+\n| Length |\n+--------+\n| Topic  |\n+--------+\n```\n```C++\nclass Comic: public Book {\n        string hero;\n    public:\n        Comic(string title, string author, int length, string hero):\n            Book{title, author, length},\n            hero{hero} {}\n\n        bool isHeavy() const { return length > 50; }\n        string getHero() const { return hero; }\n};\n```\n```C++\nCOMIC\n+--------+\n| Title  |\n+--------+\n| Author |\n+--------+\n| Length |\n+--------+\n| Hero   |\n+--------+\n```\nSubclasses inherit all members (fields & methods) from their superclass.  \nAll three classes have `title`, `author`, and `length`, methods `getTitle`, `getAuthor`, `getLength`, `isHeavy`, ... except this doesn't work.\n\n`length` is a private method in `Book`, `Text` cannot access it.\n\n**2 options:**\n\n1. _Use protected_\n```C++\nclass Book {\n        string title, author;\n    protected:  // Accessible only to this class and its subclasses\n        int length;\n    public:\n        ...\n};\n```\n\n2. _Call public method_\n```C++\nbool Text::isHeavy() const { return getLength() > 500; }\n```\n\nRecommended option is 2.\n- You have no control over what subclasses might do\n- Protected weakens encapsulation (cannot enforce invariants on protected fields)\n\nIf you want subclasses to have priviledged access\n- Keep fields private\n- Provide protected `get_` and `set_` methods\n\n## Updated object creation/destruction protocols\n\n**Creation:**\n1. Space is allocated\n1. Superclass part is constructed\n1. Fields constructed in declaration order\n1. Constructor body runs\n\n**Destruction:**\n1. Destructor body runs\n1. Fields are destructed in reverse declaration order\n1. Superclass part destructed\n1. Space deallocated\n\nMust revist everything to see the effect of inheritance\n\n## Type compatibility\n`Text`s and `Comic`s are special kinds of `Book`s - should be usable in place of `Book`s\n\n```C++\nBook b = Comic{___, ___, 75, ___};\n\n// method calls:\nb.isHeavy();\n``` \n\nThis is a light `Book`, but a heavy `Comic`. What does this return? -> Returns `false`\nIf `b` is a `Comic`, why is it acting like a `Book`? -> Because it is a `Book`!\n\nConsequence of stack-allocated objects:\n\n```C++\n// Set aside enough space to hold a book\n       +----+                +----+\n       |    |                |    |\n       +----+                +----+\nBook b |    |  = Comic {...} |    |\n       +----+                +----+\n       |    |                |    |\n       +----+      <---      +----+\n                             |    |\n                             +----+\n```\n\nKeeps only the `Book` part - `Comic` part is \"chopped off\" - **slicing**\n- So it really is just a `Book` now\n- Therefore it is `Book::isHeavy` that runs\n\nSlicing happens even if superclass & subclass are the same size.\n\nSimilarily, if you want to collect your books:\n\n```C++\nvector<Book> library;\nlibrary.push_back(Comic {...}); \n```\nonly the `Book` part will be pushed - _not_ a heterogeneous collection.\n\nAlso note:\n```C++\nvoid f(Book book[]);\nComic comics[] = {...};\nf(comics);  // Will compile but never do this!\n```\n\n- Array will be misaligned\n- Will not act like an array `Books`\n- Undefined behaviour!\n\nSlicing does not happen through pointers\n\nSo if I do this instead:\n\n```C++\nBook *p = new Comic{___, ___, 75, ___};\n\np\n+--+     +---+   \n|  | --> |   |  \n+--+     +---+\n         |   |\n         +---+\n         |   |\n         +---+\n         |   |\n         +---+\n```\n\nBut `p->isHeavy();` is still false!\n\n**Rules:** the choice of which `isHeavy` is based on the type of the pointer (static type), not the object (dynamic type).\n\nWhy? Because it's cheaper.\n\n**C++ Design Principle:** If you don't use it, you shouldn't have to pay for it.\n\nThat is if you want something more expensive, you have to ask for it. To make `*p` act like a `Comic` when it is a `Comic`:\n\n```C++\nclass Book {\n        ...\n    public:\n        ...\n        virtual bool isHeavy() const { ... }\n\n};\n\nclass Comic {\n        ...\n    public:\n        ...\n        bool isHeavy() const override { ... }\n};\n\n// Assume isHeavy is virtual\np->isHeavy();   // true!\n```\n\n`override` is a contextual keyword, is only a keyword in that specific location.\n\nNow we can have a truly heterogeneous collection.\n\n```C++\nvector<Book*> library;\nlibrary.push_back(new Book{...});\nlibrary.push_back(new Comic{...});\n\n// Even better version\nvector<unique_ptr<Book>> library; \n\nint howManyHeavy(const vector<Book*> &v) {\n    int count = 0;\n    for (auto &b: v) {\n        if (b->isHeavy()) ++count;\n    }\n\n    return count;\n}\n\nfor (auto &b: library) delete b;    // Not necessary if library is a vector of unique_ptrs\n```\n\nCorrect version of `isHeavy` is always chosen, even though we don't know what's in the vector, and the items are probably not the same type.\n\nThis is called **polymorphism**.\n\nHow do virtual methods \"work\" and why are they more expensive? (though not _significantly_ more expensive)\n- Implementation dependent, but the following is most common:\n\n**Vtables** (only contain virutal methods)\n```C++\n(1)\n+---------+\n| \"Book\"  |\n+---------+\n| isHeavy | -> Book::isHeavy\n+---------+\n\n(2)\n+---------+\n| \"Comic\" |\n+---------+\n| isHeavy | -> Comic::isHeavy\n+---------+\n```\n\nSo when we create two `Book`s `b1`, `b2`, and a `Comic b2`:\n\n```C++\nBook b1;\n\n+--------+\n| vptr   | -> (1)\n+--------+\n| Title  |\n+--------+\n| Author |\n+--------+\n| Length |\n+--------+\n\nBook b2;\n\n+--------+\n| vptr   | -> (1)\n+--------+\n| Title  |\n+--------+\n| Author |\n+--------+\n| Length |\n+--------+\n\nComic b2;\n\n+--------+\n| vptr   | -> (2)\n+--------+\n| Title  |\n+--------+\n| Author |\n+--------+\n| Length |\n+--------+\n```\n\nNon-virutal methods are just ordinary function calls.  \nIf there is at least one virtual method:\n- Compiler creates a table of function pointers:\n    - One per class\n    - The vtable\n- Each object contains a pointer to its class' vtable \n    - the `vptr`\n- Calling the virtual method => follow the `vptr` to the vtable, follow the function pointer to the correct function\n\n- `vptr` is often the \"first\" field\n    - So that a subclass object still looks like a superclass object\n    - So the program knows where the `vptr` is\n    - If there are no virtual methods, `vptr` does not exist\n\nSo virtual methods incur a cost in\n- time (Extra pointer derefs)\n- space (Each object gets a `vptr`)","tags":[],"folderPathname":"/imported/CS246E","data":{},"createdAt":"2019-10-23T17:00:05.211Z","updatedAt":"2019-12-05T17:27:46.207Z","trashed":true,"_rev":"l1OaGKMl2df"}