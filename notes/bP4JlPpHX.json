{"title":"L3: Timesharing","content":"# OS of the day\n\nExec 1\n1962 - UNIVAC 1107 is the computer it ran on\n\nA batch processor with multiprogramming (when cpu is idle, it does another).\n\nThis computer's word size was 36, not 32. This was experimentation. Some computers even used ternary.\n\n# Timesharing\nA **thread is an object** in the operating system. Like an advanced Command pattern. Look at `thread.h` in the kernel of 161.\n\n\n![](image-kk44itu7.png)\n\nWhich thread goes next? There's a great deal of scheduling to be done. There's an edge case where we switch to the **same thread**. In this case, the OS should be smart enough to do nothing and just proceed.\n\nThe first thing to do is `switchframe`.\nNote that not all the registers are saved; we use the compiler save conventions. There are only the callee registers, as designated by a convention.\n\n![](image-kk44nroz.png)\n![](image-kk44qugb.png)\n\n\n![](image-kk44wg9l.png)\n\n![](image-kk44x08a.png)\n\nThread queue, thread pool, that's the **ready** block.\n\n![](image-kk44yx7e.png)\n\n![](image-kk4514mt.png)\n\n## How do we schedule? What's the best switch-to-execute cycle?\n\nThis is enforced by the **scheduling quantum**.\n100 - 200 ms is a realistic scheduling quantum. It depends on the OS and the architecture.\n![](image-kk451ufy.png)\n\nBut how to we wrestle control away from the thread, to see if its scheduling quantum has expired? The answer is **interrupts**.\n\n![](image-kk459i78.png)\n\nAnytime hardware does anything, an interrupt is thrown. This isn't just peripherals. The CLOCK on the motherboard can throw interrupts, and it often does.\n\nHere's what the stack looks like after an interupt:\n\n![](image-kk45koei.png)\n\nEach time you run on the CPU, you get a clean block of time equal to the **scheduling quantum**. If you don't use it all, it isn't recycled.\n\n![](image-kk45lj6s.png)\n\nEven the hidden registers, like `lo` and `high`, are stored in the trap frame.\n\n![](image-kk45oxtm.png)\n\nAfter an interupt, the kernel calls thread_yeild on behalf for the thread.\n\n:::note Trap frame\n\n:::\n\n---\n\n### How to debug in OS 161\n\n```bash\nsys161 -w kernel-ASST0\n```\n\nand then, on another terminal in the same computer:\n\n```bash\ncs350-gdb kernel-ASST0\n\n(gdb) dir ../os161-1.99/kern/compile/ASST0  # give it the code\n\n(gdb) target remote unix:.sockets/gdb\n\n(gdb) b threadtest.c:64  # at the file, at this line.\n\n(gdb) b panic # breakpoint at the panic point.\n\n(gdb) c # continue. This boots inthe first terminal\n\n```\n\nnow, on the other terminal:\n\n```bash\ntt1  # run the program\n```\n\nTo see the call stack:\n\n```bash\n\n(gdb) bt  # backtrace, look at the call thread\n\n(gdb) print ch  # variable name\n\n(gdb) print curthread  #  print the current thread\n\n(gdb) print *curthread  # dereference the pointer to the current thread, look at the values.\n\n(gdb) quit # quit\n\n```\n\n","tags":[],"folderPathname":"/CS350","data":{},"createdAt":"2021-01-19T14:41:58.998Z","updatedAt":"2021-01-21T14:58:34.767Z","trashed":false,"_id":"note:bP4JlPpHX","_rev":"77-abc3fbed2e2d414321aba0a3617806d7"}