{"_id":"note:jwPGb0rPEjU","title":"Problem 26: Collecting Stats","content":"## Problem 26: Collecting Stats\n\nHow many students do I have? We want a field that transcends the class. We want a static field.\n\n```cpp\nclass Student{\n  int assns, mt, final;\n  static int count; //static means associated with the class, not one per object\n  \n  public:\n    Student(~~~~~~){++count;}\n    \n    //accessors\n    static int getCount(){return count;} //static method - no 'this' pointer. not really a method, just a scoped function.\n}\n```\nSo what does create that static field? The programmer of course.\n```cpp\nint Student::count = 0; //must define the variable\n\nStudent s1{~~~~~}, s2{~~~~~~~};\n\ncout << Student::getCount() << endl; //2\n```\n\nNow I want to count objects in other classes.\n\n```cpp\ntemplate<typename T> class Count{\n  static int count;\n  Count(){++count;}\n  Count(const Count &){++count;}\n  ~Count(){--count;}\n  static int getCount(){return count;}\n};\n\ntemplate<typename T> int Count<T>::count = 0;\n```\nAnd the way we can use this class is by inheriting from it. Big brain.\n\n```cpp\nclass Student:Count<Student>{ //private inheritance\nint assns, mt, final;\npublic:\n  Student(~~~~~~):~~~~~~~{}\n  ~~~~~\n  using Count::getCount; //make Count::getCOunt visible.\n}\n```\nThis will inherit COunt's implementation, without creating an \"is a\" relationship. Members of Count become private in Student. \n\nWe can do the same thing for other classes now too.\n\nBut why is count a template? - So we're not mixing different types. We need a Count class for Books, one for Student, etc. This gives each class its own counter, versus sharing one counter over all classes.  \n\nThis technique - inheriting from a template specialized by yourself - is called **the Curiously Recurring Template Pattern (CRTP)**. Good name.","tags":[],"folderPathname":"/imported/CS246E","data":{},"createdAt":"2019-11-26T15:11:45.932Z","updatedAt":"2019-11-26T15:34:44.179Z","trashed":true,"_rev":"3Anna3_qhaJ"}