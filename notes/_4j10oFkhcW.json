{"_id":"note:_4j10oFkhcW","title":"Problem 16: Insert/remove in the middle","content":"## Problem 16: Insert/remove in the middle\n\nA method like `vector<T>::insert(size_t i, const T &x)` is easy to write.\nBut the same method for `list<T>` would be slow (linear traversal)\nUsing iterators can be fast for both.\n```cpp\ntemplate<typename T> class vector{\n  ...\n  public:\n  iterator insert(iterator posn, const T &x){\n    ptrdiff_t offset = posn - begin();\n    increaseCap();\n    iterator newPosn = begin()+offset;\n    new (end()) T(std::move_if_noexcept (*(end()-1)));\n    ++ub.n;\n    for(iterator it= end() - 1; it !=newPosn; --it){\n      *it = std::move_if_noexcept(*(it-1));\n    }\n    *newPosn = x;\n    return newPosn;\n  }\n}\n```\nIs it exception safe?\nAssuming T's copy/move ctor copy/move assign are exception safe (at least basic guarantee), insert also offers the basic guarantee.\nYou may get a partially-shuffled vector, but it will be a valid vector.\n!!! note Note:\nIf you have other iterators pointing at the vector, the iterators will point at the same spot, but at a different item.\n!!!\n\n!!! hint Convention:\nafter a call to insert or erase, all iterators pointing after the point of insertion or erasure are considered invalid and should not be used. \n!!!\n\nSimilarly, if a reallocation happens, all iterators that you had are now invalid.\n\nBut now, there's a problem with `push_back`.\nIf placement new throws, the vector is the same, but iterators were invalidated!\n\nTo fix: don't throw away the old array until you have placed the item.\n- place the last item first (placement new)\n- `uninitialized_copy_or_move` the old array\n- catch any exceptions - destroy the last item +rethrow\n- if all succeeds, swap arrays, destroy_elements on the old one.\n\n---\nWe can use iterators to modify certain parts of a list or a vector.\nWhat if I want to transform a list to a vector, or vice versa?\nMake the type variables stand for the iterators, not the container elements.\n\n```cpp\ntemplate <typename InIter, typename OutIter, typename Fn>\n  void transform (InIter start, InIter finish, OutIter target, Fn f){\n    while (start != finish){\n      *target = f(*start);\n      ++start; //works over vector iterators, list iterators, or any other iterators.\n      ++target;\n    }\n  }\n```\nInIter/OutIter can be any types that support ++, *, !=.\n\nFn can be any type that supports function application.\nEg.\n```cpp\nclass Plus{ //this is what we call a function object.\n  int n;\n  public;\n    Plus(int n):n{n}{}\n    int operator()(int m){return n+m;}\n}\n```\n\n!!! note Lambdas\n`[](int n){return n+1;}` is lambda syntax for C++. But it's not really a lambda.\n`[capture list](parameter list) mutable? noexcept? { body }`\nLambdas are just classes that have a round bracket operator.\nCapture list - provides access to selected vars in the enclosing scope.\nif mutable, then things in the capture list can be mutated.\n!!!\nLambdas translate to\n```cpp\nclass ~~~~~~~~~{ //anonymous class\n  T1 a;\n  T2 &b;\n  public:\n    ~~~~~~~~~(T1 a, T2 &b):a{a},b{b}{}\n    auto operator()(int x) const {body;}\n};\n~~~~~{a,b}.operator()(......);\n```\n\nIf the lambda is declared mutable, then operator () is not const.\n\n### Midterm coverage ends.","tags":[],"folderPathname":"/imported/CS246E","data":{},"createdAt":"2019-10-22T14:33:40.744Z","updatedAt":"2019-12-11T20:12:23.901Z","trashed":true,"_rev":"e_LJZfBKHlH"}