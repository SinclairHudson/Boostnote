{"_id":"note:xzxA3GKAHw_","title":"Problem 32: A fixed-size object allocator","content":"## Problem 32: A fixed-size object allocator\n\nAs an example of how a custom allocator can be very fast, we'll write a fixed-size object allocator.\n\nWhy is it faster?\nAll allocated \"chunks\" are the same size, so there's no need to keep track of sizes.\nMany traditional allocators store the size of the block before the pointer so that the allocator knows how much memory is allocated to that pointer. How much memory should we free when we free a pointer?\n\nSo we save space and save time. We don't have to hunt for a block of the right size, and there's no hidden size field.\n\nApproach: Create a pool of memory - an array large enough to hold n T objects:\n\nWhen a slot in the array is given to the client, it will act as a T objects.\nWhen we have it, it will act as a node in a linked list.\nStore an int in each slot - index(not a pointer) of the next free slot.\nStore the index of the first free slot.\n0| ->||1|2|3|4|...|-1|\n---|---|---|-|-|-|-|-|-\n\n\n~~ a bunch of things I don't want to draw out ~~\nAllocation and deallocation are both constant time and very fast.\n```cpp\ntemplate<typename T, int n> class fixedSizeAllocator{\n  union Slot{\n    int next;\n    T data;\n    Slot():next{0}{}\n  };\n  Slot theSlots[n];\n  int firstAvailable = 0;\n  public:\n    fixedSizeAllocator(){\n      for(int i = 0; i < n -1; ++i) theSLots[i] = i +1;\n      theSlots[n-1] = -1;\n    }\n    T *allocate() noexcept{\n      if(firstAvailable == -1) return nullptr;\n      T *result = &(theSlots[firstAvailable].data);\n      firstAvailable = theSlots[firstAvailable].next;\n      return result;  \n    }\n    void deallocate(void *item) noexcept{\n      int index = (static_cast<char *>(item) - reinterpret_cast<char *>(theSlots))/sizeof(slot);\n      theSlots[index].next=firstAvailable;\n      firstAvailable = index;\n    }\n};\n```\n\nAnd here's how you use it in a class:\n```cpp\nclass Student final{\n  int assns, mt, final;\n  static fixedSizeAllocator <Student, SIZE> pool; //how many slots do you want?\n  public:\n    static void *operator new (size_t size){\n      if(size!=sizeof(Student)) throw std::bad_alloc{};\n      while (true){\n        void *p = pool.allocate();\n        if(p) return p;\n        auto h = std::get_new_handler();\n        if(h) h();\n        else throw std::bad_alloc{};\n      }\n    }\n    static void operator delete(void *p) noexcept{\n      if(!p) return;\n      pool.deallocate(p);\n    }\n};\n\nfixedSizeAllocator<Student, SIZE> Student::pool;\n\n```\nExample main:\n\n```cpp\nint main(){\n  Student *s1 = new Student;\n  Student *s2 = new Student; //custom allocator\n  delete s1;\n  delete s2; //custom deallocator\n}\n```\n\nIn testing, this custom allocator and deallocator run twice as fast as the standard ones!\n\nWhere do s1 and s2 reside?\nIt's actually in the **static memory**. Remember we declared it `static`. It matters where `pool` lives. It's not the heap or the stack.\n\n* We use a union to treat a slot as both an int and a Tobj.\n  * This ensures that no memory is wasted on bookkeeping.\n  * alternative - use a struct instead of a union, and store the next undex adjacent to the T object.\n* Advantage of a union: no wasted memory\n* Disadvantage of a union: if you access a dangling T ptr, you can corrupt the linked list.\n```cpp\nStudent *s = new Student;\ndelete s;\ns->setAssns(~~~~~~); //will probably corrupt the list\n```\n\nSO, following dangling pointers can be **VERY** dangerous.\n\nWith a struct, the same issue exists, but the 'next' field is before the T obj pointed to by s, so you have to work hard to corrupt it.\nTo corrupt, you would have to do:\n```cpp\nreinterpret_cast<int *>(s)[-1] = ~~~~~~; //not something you do by accident...\n```\n\nUsing a union - if one of the fields has a constructor, you have to give the union a constructor - since it's a union, the cunstructor should initialize only one field.\n\nOn the other hand - if you are using a struct, you will have difficulty if T does not have a default constructor.\n\nExample:\n```cpp\nstruct Slot{\n  int n;\n  T data;\n};\n\nslot theSlots[n]; //can't do this if T has no default constructor!\n\n```\nAnd we can't do operator new/placement new because we're writing operator new!\n\nWorkaround:\n```cpp\nstruct SlotChar{\n  char arr[sizeof(Slot)];\n};\n```\nor, if we want to use unions:\n```cpp\nunion SlotChar{ //same as a slot \n  char dummy;\n  Slot s;\n  SlotChar():dummy{0}{} // we can initialize the char and avoid calling a constructor\n}\n```\nWhichever one we choose:\n```cpp\nSlotChar theSlotChars[n];\nSlot *theSlots = reinterpret_cast<Sot *s>(theSlotChars);\n```\n\n---\n\nWhy do we store indices in the linked list rather than pointers? Because they're smaller.\nInts are smaller than pointers on this machine.\nSo we waste no memory, as long as sizeof(T) >= sizeof(int)\nWe do waste memory if T is smaller than an int.\nCould use a smaller type than int, like a `short` or a `char`, however they do have a limit on how many items they can represent. \n\n---\n\nWhy is the class Student declared `final`?\nOur fixed-size allocator only works if all of our objects are the same size. So we can't have a sublcass, because that could **add fields and change the size**.\nAlternatively, we could check the size, and throw and exception if it is not the right size. However, this is a runtime check so it's not as good.\nAlternatively, we could get the derived class to have its own allocator.","tags":[],"folderPathname":"/CS246E","data":{},"createdAt":"2019-11-28T15:47:32.227Z","updatedAt":"2019-12-03T15:45:23.953Z","trashed":false,"_rev":"OmgJXCYj88C"}