{"_id":"note:gtp86yhmeo7","title":"Problem 06: I want a constant vector","content":"## Problem 06: I want a constant vector\n\nSay we want to print a vector.\n```cpp\nostream &operator <<(ostream &out, const vector &v){\n  for(size_t i=0, i < v.size(); ++i){\n    out << v.itemAt(i) << \" \";\n    }\n    return out;\n  }\n}\n```\nWon't compile! This is because you can't call size or itemAt on a const object.\nThe compiler can't be sure that these methods aren't changing anything.\n\nWe have to declare the methods to be `const`, to guarantee the compiler that they won't modify the object.\n```cpp\nstruct vector{\n...\n  size_t size() const;\n  int &itemAt(size_t i) const;\n  //means these methods wil not modify fields => can be called on const objects.\n\n  size_t vector::size()const{\n    return n;\n  }\n  int &vector::itemAt(size_t i) const {\n    return theVector[i];\n  }\n}\n```\nNow the loop will work.\nBut,\n```cpp\nvoid f(const vector &v){\n  v.itemAt(0) = 4; //and this WORKS! So v is not very const.\n}\n```\nV is a const object - that means you cannot change n, cap, theVector(ptr), but you **can** change data pointed to by it.\n\n```cpp\nstruct Vector{\n  ...\n  const int &itemAt(size_t i) const;\n}\n\nconst int &vector::itemAt(size_t i) const {return theVector[i];}\n```\nNow `v.itemAt(0)=4` won't compile if v is const.\n\nBut it also won't compile if v **isn't** const!\n\nConst overloading is the fix :)\n\n```cpp\nstruct vector{\n  const int &itemAt(size_t i) const; //will be called if the item is const\n  int &itemat(size_t i); //will be called if the item is not const\n}\n```\n`inline` - for really simple functions, just substitute the function call with its body.\nThis saves a lot of time, because we don't have to make another stack frame, etc.\n```cpp\ninline size_t size() const {return s;} //really simple accessor method.\n\n```\nBut it's just a suggestion, the compiler doesn't have to follow it. inline has to be in the .h files, otherwise the compiler just won't see it lol.\n\nNow `v.itemAt(0) = 4` will compile iff v is not const.\n\n```cpp\nstruct vector{\n  size_t size() const {return n;}\n  const int &operator[](size_t i) const {return theVector[i];}\n  int &operator[i](size_t i){return theVector[i];}\n  //the method body has been written inside the class\n  //implicitly declares the methods to be inline.\n  ostream &operator<<(ostream &out, const vector &v){\n    for(size_t i = 0; i < v.size(); ++i){\n      out << v[i] << \" \";\n    }\n    return out;\n  }\n}\n```\n","tags":[],"folderPathname":"/CS246E","data":{},"createdAt":"2019-09-24T15:05:20.197Z","updatedAt":"2019-10-30T21:41:23.828Z","trashed":false,"_rev":"z6Rhh19EOMQ"}