{"_id":"note:_H17XEl_knB","title":"Problem 03: Linear Collections and Memory Management","content":"## Problem 03: Linear Collections and Memory Management\n\n#### Arrays:\n\n```cpp\nint a[10]; //array of 10 ints on the stack\nint *p = new int[10]; //array of 10 ints on the heap\n\ndelete[] p; //to delete an array\n```\nUse `delete` any time you use `new`.\nUse `delete[]` any time you use `new...[...]`.\n\nAnd what if we want to expand our array?\n**There is no realloc in C++ for new/delete.**\n\nSo we're going to use absraction and data structures.\n#### vector.h\n```cpp\nnamespace CS246E{\n  struct vector{\n    int *theVector;\n    size_t size, cap;\n  };\n  \n  const size_t startSize = 1;\n  vector makeVector();\n  \n  size_t size(const vector &v);\n  \n  int &itemAt(const vector &v, size_t i); //accessor, return a reference\n  \n  void push_back(vector &v, int n);\n  void pop_back(vector &v);\n  void dispose(vector &v)\n}\n```\n#### vector.cc\n```cpp\n#include \"vector.h\"\n\nnamespace { //an unnamed namespace makes the functions private\n//you can't call these methods outside the namespace\n//this prevents tampering\n  void increaseCap(CS246E::vector &v){\n    if(v.size==v.cap){ //if we're full\n      int *newVec = new int[2*v.cap]; //create a new array that's twice as big.\n      for(size_t i = 0; i < v.cap; ++i){\n        newVec[i]=v.theVector[i]; //copy all elements over\n      }\n      delete[] v.theVector;\n      v.theVector = newVec;\n      v.cap *=2; //double cap to reflect new max\n    }\n  }\n} //end of unnamed namespace\n\nint &CS246E::itemAt(const vector &v, size_t i){\n  return v.theVector[i];\n}\nvoid CS246E::push_back(vector &v, int n){\n  increaseCap(v);\n  v.theVector[v.size++] = n;\n}\nvoid CS246E::pop_back(vecotr &v){\n  if(v.size > 0){\n    --v.size;\n  }\n}\nvoid dispose(vector &v){\n  delete[] v.theVector;\n}\n\n//implementations of methods we left unimplemented in vector.h.\nCS246E:vector CS246E::makeVector(){\n  CS246E::vector v{new int[startsize],0,startSize};\n  return v;\n}\n```\n\n#### main.cc\n```cpp\n#include \"vector.h\"\nusing CS246E::vector; //vector equivalent to CS246E::vector\n\nint main(){\n  vector v = CS246E::make_vector();\n  push_back(v,1);\n  push_back(v,10);\n  push_back(v,100);\n  \n  itemAt(v, 0) = 2; //fine, we can mutate because we're dealing with references.\n}\n```\nNotice how we can just use `push_back` in main and not `CS26E::push_back`. Why is that?\n\n!!! note Argument Dependent Lookup (ADL)\nIf the type of a function f's argument belongs to a namespace n then C++ will search the namespace n for f, as well as the current scope. It's just a small little shortcut. Also called Koenig Lookup.\n!!!\n\nSince `v` belongs to CS246E namespace, C++ will search CS246E for `push_back`.\n\n---\nWhat if we forget to call make_vector when we want to make a vector? We get an uninitialized vector.\nWhat if we forget to call dispose? we leak memory. It would be handy to have `dispose(v)` called automatically when v goes out of scope.\n\n### Introduction to classes\nHere we are. Object Oriented Programming, finally.\n* **classes** are like structs with functions associated with them.\n* **objects** are instances of a class.\n  * **instance variables** are the fields of a class.\n* **methods** are functions inside the class, associated with that class.\n  * **destructors** are functions that delete/clean up the struct and free associated memory.\n  * **constructors** are functions that create objects from classes, allocating memory and setting values.\n  * **accessor methods** are functions that just return fields from the class.\n  * **mutator methods** are functions that mutate the object in some way, potentially re-allocating memory.\n\nLet's do an example:\n```cpp\nclass Student{ //class\n  int assns, mt, final; //instance variables\n  \n  float grade(){ //accessor method\n    return assns*0.4+mt*0.2+final*0.4;\n  }\n  \n  Student(inst a, int m, int f){ //constructor method\n    assns = a;\n    mt = m;\n    final = f;\n  }\n}\n\nint main(){\n  Student bob{60,70,80}; //bob is an object, constructor called\n  Student BOB = Student{100,70,80}; //equivalent\n  Student * alice = new Student{90,90,100}; //alice is on the heap!\n  Student bob; //default constructor, crashes \n  \n}\n```\n\nIt should be noted that there's a default constructor and destructor for each class. They can be overwritten by any constructor, so as soon as you write a constructor you can't use the default. Default constructors initialize all instance variables to default values. If the instance variables are objects, then they are constructed with default constructors. A default destructor deletes all the instance variables in a **shallow fashion**.\n\n!!! attention `this`\nFormally, methods differ from functions because methods take an implicit parameter called `this`. `this` is a pointer to the object itself. When we say `assns` in `grade()`, it's equivalent to `this->assns`.\n!!!\n\n### Object creation Sequence:\n1) Space is allocated for the instance variables\n2) Superclass constructor runs (see problem 18)\n3) Fields are constructed in declaration order\n4) Constructor body runs\n\nSo then the instance variable (field) initialization **actually happens twice**. Once in 3, and then again in 4 when the constructor body runs.\n\nThis is innefficient, so of course there's a fix\n\n### Member Initialization List (MIL)\n\nMIL must be used for fields that are constants, like\n* constants\n* references\n* objects without default constructors\n\n```cpp\nclass Student{\n   int assns, mt, final;\n   String name; //object\n   Student(string name, int assns, int mt, int final){\n    this->name = name;\n    ... //etc\n   } //this constructor is flawed. The name is initialized as the empty string first, and then\n    //in the body it's reassigned. Use MIL instead\n  \n  Student(string name, int assns, int mt, int final):assns{assns},mt{mt},final{final},name{name}{}\n  //so this consructor is equivalent to the one above, but MIL is part of part 3 of object creation.\n  //part 4, the body of the constructor, is empty.\n}\n```\n\n---\n\nWatch out for single argument constructors. They can create implicit conversions.\n\n```cpp\nNode n{4}; //OK\nNode n = 4; //OK ish. int is implicitly converted into a node.\nvoid f(Node n);\nf(4); //again fine, but 4 is implicitly converted into a node. You probably don't want this\n```\n\nTo prevent implicit conversions with single-argument constructors, use the keyword `explicit`.\n\n```cpp\nstruct Node{\nexplicit Node(~~~~~~~);   {~~~~}\n};\n```\nAnd now there's no implicit conversion; explicit nodes only.\n\n## Object Destruction\n\nObjects must be destructed as well.\n\nA method called the destructor (dtor) runs automatically. There is a built-in destructor, calls dtors on all fields that are objects.\n\n### Object Destruction sequence\n\n1) dtor body runs\n2) The fields are destructed (dtors are called on fields that are objects) in reverse declaration order. \n3) Superclass destructor runs (problem 18)\n4) Space is deallocated\n\nConsider the Node structure.\n```cpp\nStruct Node{\n  int data;\n  Node *next;\n};\n```\nThe dtor actually does nothing; neither field is an object.\n```cpp\nNode *n=new Node{3, new Node{4, new Node {5, nullptr}}};\ndelete n; //only deletes the first node, so we're in trouble\n```\n### Writing our own dtor:\n```cpp\nstruct Node{\n  ...\n  ~Node(){delete next;} //on delete, delete the next reference\n};\ndelete n; //now frees the entire list\n```\n\nAlso consider:\n\n```cpp\n{\n...\n// n is on the stack\nNode n {1, new Node {2, new Node {3, nullptr}}};\n} //scope of n ends\n```\n\nBut the nodes with `new` in front of them are on the heap. However, thanks to our new, custom dtor, the whole linked list is freed. This process is actually recursive. Our dtor is a recursive function.\n\n!!! note Key Concept\nA ctor _always_ runs when objects are created.\nA dtor is _always_ run when they are destroyed.\n!!!\n\n---\n\nBack to the vector example - let's turn it into a class:\n#### vector.h\n```cpp\n  namespace CS246E{\n    struct vector{\n      int *theVector;\n      size_t n, cap;\n      vector();\n      size_t size();\n      inst &itemAt(int i);\n      void push_back(int n);\n      void pop_back();\n      ~vector();\n    };\n  }\n```\n\n#### vector.cc\n\n```cpp\n#include \"vector.h\"\nnamespace{ //static\n  void increaseCap(SC246E::vector &v){...}\n}\nCS246E::vector::vector():theVector{new int[1]}, n{0}, cap{1}{}\nsize_t CS246E::vector::size(){return n;};\n...\nCS246E::vector::~vector(){delete []theVector;}\n```\n\n#### main.cc\n\n```cpp\nusing CS246E::vector;\nint main(){\n  vector v; //ctor is automatically called here\n  v.push_back(10);\n  v.push_back(10);\n  v.push_back(100);\n  \n  v.itemAt(0)=2;\n} //no call to dispose -dtor cleans v up automatically.\n```\n\n\nNow it's really simple. The client cannot forget to deallocate or allocate vectors properly, and it still works as intended. This is the power of object oriented programming.\n\n---\n\nThis is the same as when files were being opened and closed. We didn't have to call fopen and fclose explicitly because they were abstracted away in ctor and dtor of the class.","tags":[],"folderPathname":"/CS246E","data":{},"createdAt":"2019-10-27T19:54:05.986Z","updatedAt":"2019-12-04T22:06:27.617Z","trashed":false,"_rev":"TepZLhBqbSb"}